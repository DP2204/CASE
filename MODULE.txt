<ul class="courier-list">
  <li *ngFor="let courier of couriers$ | async" class="courier-item">
    
    <!-- Header -->
    <div class="courier-header">
      <div>
        <b>Courier Partner:</b>
        <span>{{ courier.courierPartnerCategory }}</span>
      </div>

      <div class="waybill">
        <b>Waybill No:</b>
        <span>{{ courier.courierPartnerWaybillNo }}</span>
      </div>
    </div>

    <!-- Meta -->
    <div class="meta-details">
      <div>
        <span class="align">Created by:</span>
        <span>
          <i class="fas fa-user"></i> {{ courier.createdBy }}
          &nbsp; <i class="fas fa-calendar"></i> {{ formatDate(courier.createdOn) }}
        </span>
      </div>

      <div *ngIf="courier.updatedOn">
        <span class="align">Updated by:</span>
        <span>
          <i class="fas fa-user"></i> {{ courier.updatedBy }}
          &nbsp; <i class="fas fa-calendar"></i> {{ formatDate(courier.updatedOn) }}
        </span>
      </div>
    </div>

    <!-- Actions -->
    <div class="courier-actions">
      <button
        pButton
        icon="pi pi-pencil"
        class="p-button-sm p-button-text p-button-info"
        (click)="onModifyCourier.emit(courier)"
        [disabled]="isDisabled"
        *ngIf="showModify"
        adminSelenium="courier_modify_btn"
      ></button>

      <button
        pButton
        icon="pi pi-trash"
        class="p-button-sm p-button-text p-button-danger"
        (click)="onDeleteCourier.emit(courier)"
        [disabled]="isDisabled"
        *ngIf="showDelete"
        adminSelenium="courier_delete_btn"
      ></button>
    </div>

  </li>
</ul>





-----------------------



package com.bnpparibas.dpw.controller;

import com.bnpparibas.dpw.api.CourierApi;
import com.bnpparibas.dpw.controller.model.Courier;
import com.bnpparibas.dpw.service.CourierService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequiredArgsConstructor
public class CourierController implements CourierApi {

    private final CourierService courierService;

    @Override
    @PreAuthorize("hasopsPermission(#branchCode, null, 'WriteCourrier')")
    public ResponseEntity<Courier> createCourier(String branchCode, String countryCode, String bnppuid, String stepName, Courier body) {
        Courier courierModel = courierService.createCourier(bnppuid, body, stepName);
        return new ResponseEntity<>(courierModel, HttpStatus.OK);
    }

    @Override
    @PreAuthorize("hasopsPermission(#branchCode, null, 'ReadCourrier')")
    public ResponseEntity<List<Courier>> searchCourierList(String branchCode, String countryCode, String bnppuid, String eventId) {
        List<Courier> courierList = courierService.getCourierListByEventId(eventId, bnppuid);
        return new ResponseEntity<>(courierList, HttpStatus.OK);
    }

    @Override
    @PreAuthorize("hasopsPermission(#branchCode, null, 'UpdateCourrier')")
    public ResponseEntity<Courier> updateCourier(String branchCode, String countryCode, String bnppuid, String courierId, String stepName, Courier body) {
        Courier updated = courierService.updateCourier(bnppuid, courierId, body, stepName);
        return new ResponseEntity<>(updated, HttpStatus.OK);
    }

    @Override
    @PreAuthorize("hasopsPermission(#branchCode, null, 'DeleteCourrier')")
    public ResponseEntity<Void> deleteCourier(String branchCode, String countryCode, String bnppuid, String courierId, String stepName) {
        courierService.deleteCourier(courierId, bnppuid, stepName);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }
}

___________________



@Override
@Transactional(rollbackFor = Exception.class)
public void deleteCourier(String courierId, String bnppuid, String stepName) {
    Long id;
    try {
        id = Long.parseLong(courierId);
    } catch (NumberFormatException ex) {
        throw new DpwEntityNotFoundException("Invalid courier ID format: " + courierId);
    }

    Optional<CourierEntity> optional = courierRepository.findById(id);
    if (optional.isEmpty()) {
        throw new DpwEntityNotFoundException("Courier entry not found for id: " + courierId);
    }

    CourierEntity entity = optional.get();

    if (stepName != null) {
        dpwEventHelper.checkLockForAllApis(stepName, bnppuid, entity.getEventId());
    }

    courierRepository.deleteById(id); // âœ… this now receives a Long
}


__________________________

@Override
@Transactional(rollbackFor = Exception.class)
public Courier updateCourier(String bnppuid, String courierId, Courier courier, String stepName) {
    Long id;
    try {
        id = Long.parseLong(courierId);
    } catch (NumberFormatException ex) {
        throw new DpwEntityNotFoundException("Invalid courier ID format: " + courierId);
    }

    validateEventId(courier.getEventId());

    Optional<CourierEntity> optional = courierRepository.findById(id);
    if (optional.isEmpty()) {
        throw new DpwEntityNotFoundException("Courier entry not found for id: " + courierId);
    }

    if (stepName != null) {
        dpwEventHelper.checkLockForAllApis(stepName, bnppuid, courier.getEventId());
    }

    CourierEntity entity = optional.get();

    entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
    entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());

    String resolvedUpdatedBy = dpwEventHelper.setCreatedOrClosedByField(
            courier.getUpdatedBy(), bnppuid, courier.getUpdatedByUser(), true);

    entity.setUpdatedBy(resolvedUpdatedBy);
    entity.setUpdatedOn(LocalDateTime.now(ZoneOffset.UTC));

    CourierEntity saved = courierRepository.save(entity);
    return mapEntityToModel(saved); // This assumes you have this method in parent class
}




--------
package com.bnpparibas.dpw.service.impl;

import com.bnpparibas.dpw.controller.model.Courier;
import com.bnpparibas.dpw.entity.CourierEntity;
import com.bnpparibas.dpw.entity.EventEntity;
import com.bnpparibas.dpw.exception.DpwEntityNotFoundException;
import com.bnpparibas.dpw.helper.DpwEventHelper;
import com.bnpparibas.dpw.repository.CourierRepository;
import com.bnpparibas.dpw.repository.EventRepository;
import com.bnpparibas.dpw.service.CourierService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class CourierServiceImpl implements CourierService {

    @Autowired
    private CourierRepository courierRepository;

    @Autowired
    private EventRepository eventRepository;

    @Autowired
    private DpwEventHelper dpwEventHelper;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Courier createCourier(String bnppuid, Courier courier, String stepName) {
        validateEventId(courier.getEventId());

        if (stepName != null) {
            dpwEventHelper.checkLockForAllApis(stepName, bnppuid, courier.getEventId());
        }

        CourierEntity entity = new CourierEntity();
        entity.setEventId(courier.getEventId());
        entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
        entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());

        String resolvedCreatedBy = dpwEventHelper.setCreatedOrClosedByField(
                courier.getCreatedBy(), bnppuid, courier.getCreatedByUser(), true
        );
        entity.setCreatedBy(resolvedCreatedBy);
        entity.setCreatedOn(LocalDateTime.now(ZoneOffset.UTC));

        CourierEntity saved = courierRepository.save(entity);
        return mapEntityToModel(saved);
    }

    @Override
    public List<Courier> getCourierListByEventId(String eventId, String bnppuid) {
        List<CourierEntity> list = courierRepository.findByEventId(eventId);
        return list.stream().map(this::mapEntityToModel).collect(Collectors.toList());
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Courier updateCourier(String bnppuid, String courierId, Courier courier, String stepName) {
        Long id = parseId(courierId);
        validateEventId(courier.getEventId());

        Optional<CourierEntity> optional = courierRepository.findById(id);
        if (optional.isEmpty()) {
            throw new DpwEntityNotFoundException("Courier entry not found for id: " + courierId);
        }

        if (stepName != null) {
            dpwEventHelper.checkLockForAllApis(stepName, bnppuid, courier.getEventId());
        }

        CourierEntity entity = optional.get();
        entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
        entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());

        String resolvedUpdatedBy = dpwEventHelper.setCreatedOrClosedByField(
                courier.getUpdatedBy(), bnppuid, courier.getUpdatedByUser(), true
        );
        entity.setUpdatedBy(resolvedUpdatedBy);
        entity.setUpdatedOn(LocalDateTime.now(ZoneOffset.UTC));

        CourierEntity saved = courierRepository.save(entity);
        return mapEntityToModel(saved);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void deleteCourier(String courierId, String bnppuid, String stepName) {
        Long id = parseId(courierId);

        Optional<CourierEntity> optional = courierRepository.findById(id);
        if (optional.isEmpty()) {
            throw new DpwEntityNotFoundException("Courier entry not found for id: " + courierId);
        }

        CourierEntity entity = optional.get();

        if (stepName != null) {
            dpwEventHelper.checkLockForAllApis(stepName, bnppuid, entity.getEventId());
        }

        courierRepository.deleteById(id); // Hard delete
    }

    private Courier mapEntityToModel(CourierEntity entity) {
        Courier model = new Courier();
        model.setId(entity.getId() != null ? entity.getId().toString() : null);
        model.setEventId(entity.getEventId());
        model.setCourierPartnerCategory(entity.getCourierPartnerCategory());
        model.setCourierPartnerWaybillNo(entity.getCourierPartnerWaybillNo());
        model.setCreatedBy(entity.getCreatedBy());
        model.setCreatedOn(entity.getCreatedOn());
        model.setUpdatedBy(entity.getUpdatedBy());
        model.setUpdatedOn(entity.getUpdatedOn());
        return model;
    }

    private void validateEventId(String eventId) {
        if (!eventRepository.existsById(eventId)) {
            throw new DpwEntityNotFoundException("Invalid eventId: " + eventId);
        }
    }

    private Long parseId(String idStr) {
        try {
            return Long.parseLong(idStr);
        } catch (NumberFormatException ex) {
            throw new DpwEntityNotFoundException("Invalid ID format: " + idStr);
        }
    }
}





-----------------------



package com.bnpparibas.dpw.service.impl;

import com.bnpparibas.dpw.entity.CourierEntity;
import com.bnpparibas.dpw.entity.EventEntity;
import com.bnpparibas.dpw.exception.DpwEntityNotFoundException;
import com.bnpparibas.dpw.helper.DpwEventHelper;
import com.bnpparibas.dpw.model.Courier;
import com.bnpparibas.dpw.repository.CourierRepository;
import com.bnpparibas.dpw.repository.EventRepository;
import com.bnpparibas.dpw.service.CourierService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class CourierServiceImpl implements CourierService {

    @Autowired
    private CourierRepository courierRepository;

    @Autowired
    private EventRepository eventRepository;

    @Autowired
    private DpwEventHelper dpwEventHelper;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Courier createCourier(String bnppuid, Courier courier, String stepName) {
        validateEventId(courier.getEventId());

        if (stepName != null) {
            dpwEventHelper.checkLockForAllApis(stepName, bnppuid, courier.getEventId());
        }

        CourierEntity entity = new CourierEntity();
        entity.setEventId(courier.getEventId());
        entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
        entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());

        String resolvedCreatedBy = dpwEventHelper.setCreatedOrClosedByField(
                courier.getCreatedBy(), bnppuid, courier.getCreatedByUser(), true
        );
        entity.setCreatedBy(resolvedCreatedBy);
        entity.setCreatedOn(LocalDateTime.now(ZoneOffset.UTC));

        CourierEntity saved = courierRepository.save(entity);
        return mapEntityToModel(saved);
    }

    @Override
    public List<Courier> getCourierListByEventId(String eventId, String bnppuid) {
        List<CourierEntity> list = courierRepository.findByEventId(eventId);
        return list.stream().map(this::mapEntityToModel).collect(Collectors.toList());
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Courier updateCourier(String bnppuid, Long id, Courier courier, String stepName) {
        validateEventId(courier.getEventId());

        Optional<CourierEntity> optional = courierRepository.findById(id);
        if (optional.isEmpty()) {
            throw new DpwEntityNotFoundException("Courier entry not found for id: " + id);
        }

        if (stepName != null) {
            dpwEventHelper.checkLockForAllApis(stepName, bnppuid, courier.getEventId());
        }

        CourierEntity entity = optional.get();
        entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
        entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());

        String resolvedUpdatedBy = dpwEventHelper.setCreatedOrClosedByField(
                courier.getUpdatedBy(), bnppuid, courier.getUpdatedByUser(), true
        );
        entity.setUpdatedBy(resolvedUpdatedBy);
        entity.setUpdatedOn(LocalDateTime.now(ZoneOffset.UTC));

        CourierEntity saved = courierRepository.save(entity);
        return mapEntityToModel(saved);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void deleteCourier(Long id, String bnppuid) {
        if (!courierRepository.existsById(id)) {
            throw new DpwEntityNotFoundException("Courier entry not found for id: " + id);
        }
        courierRepository.deleteById(id); // Hard delete
    }

    private Courier mapEntityToModel(CourierEntity entity) {
        Courier model = new Courier();
        model.setId(entity.getId());
        model.setEventId(entity.getEventId());
        model.setCourierPartnerCategory(entity.getCourierPartnerCategory());
        model.setCourierPartnerWaybillNo(entity.getCourierPartnerWaybillNo());
        model.setCreatedBy(entity.getCreatedBy());
        model.setCreatedOn(entity.getCreatedOn());
        model.setUpdatedBy(entity.getUpdatedBy());
        model.setUpdatedOn(entity.getUpdatedOn());
        return model;
    }

    private void validateEventId(String eventId) {
        if (!eventRepository.existsById(eventId)) {
            throw new DpwEntityNotFoundException("Invalid eventId: " + eventId);
        }
    }
}



------------------66666----------
package com.bnpparibas.dpw.service.impl;

import com.bnpparibas.dpw.entity.CourierEntity;
import com.bnpparibas.dpw.entity.EventEntity;
import com.bnpparibas.dpw.exception.DpwEntityNotFoundException;
import com.bnpparibas.dpw.model.Courier;
import com.bnpparibas.dpw.repository.CourierRepository;
import com.bnpparibas.dpw.repository.EventRepository;
import com.bnpparibas.dpw.service.CourierService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class CourierServiceImpl implements CourierService {

    @Autowired
    private CourierRepository courierRepository;

    @Autowired
    private EventRepository eventRepository;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Courier createCourier(String bnppuid, Courier courier) {
        validateEventId(courier.getEventId());

        CourierEntity entity = new CourierEntity();
        entity.setEventId(courier.getEventId());
        entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
        entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());
        entity.setCreatedBy(bnppuid);
        entity.setCreatedOn(LocalDateTime.now(ZoneOffset.UTC));

        CourierEntity saved = courierRepository.save(entity);
        return mapEntityToModel(saved);
    }

    @Override
    public List<Courier> getCourierListByEventId(String eventId, String bnppuid) {
        List<CourierEntity> list = courierRepository.findByEventId(eventId);
        return list.stream().map(this::mapEntityToModel).collect(Collectors.toList());
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Courier updateCourier(String bnppuid, Long id, Courier courier) {
        validateEventId(courier.getEventId());

        Optional<CourierEntity> optional = courierRepository.findById(id);
        if (optional.isEmpty()) {
            throw new DpwEntityNotFoundException("Courier entry not found for id: " + id);
        }

        CourierEntity entity = optional.get();
        entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
        entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());
        entity.setUpdatedBy(bnppuid);
        entity.setUpdatedOn(LocalDateTime.now(ZoneOffset.UTC));

        CourierEntity saved = courierRepository.save(entity);
        return mapEntityToModel(saved);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void deleteCourier(Long id, String bnppuid) {
        if (!courierRepository.existsById(id)) {
            throw new DpwEntityNotFoundException("Courier entry not found for id: " + id);
        }
        courierRepository.deleteById(id); // hard delete
    }

    private Courier mapEntityToModel(CourierEntity entity) {
        Courier model = new Courier();
        model.setId(entity.getId());
        model.setEventId(entity.getEventId());
        model.setCourierPartnerCategory(entity.getCourierPartnerCategory());
        model.setCourierPartnerWaybillNo(entity.getCourierPartnerWaybillNo());
        model.setCreatedBy(entity.getCreatedBy());
        model.setCreatedOn(entity.getCreatedOn());
        model.setUpdatedBy(entity.getUpdatedBy());
        model.setUpdatedOn(entity.getUpdatedOn());
        return model;
    }

    private void validateEventId(String eventId) {
        if (!eventRepository.existsById(eventId)) {
            throw new DpwEntityNotFoundException("Invalid eventId: " + eventId);
        }
    }
}




--------------------------------------------
@WebMvcTest(StaticDataController.class)
class StaticDataControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private ExtTrackAndTraceMappingService extTrackAndTraceMappingService;

    @Autowired
    private ObjectMapper mapper;

    @Test
    void testGetExternalTraceAndTrackMapping_shouldReturnList() throws Exception {
        ExternalTrackAndTraceMapping mapping = new ExternalTrackAndTraceMapping();
        List<ExternalTrackAndTraceMapping> mappings = List.of(mapping);

        when(extTrackAndTraceMappingService.getMapping("branchCode==30004;countryCode==FR")).thenReturn(mapping);

        mockMvc.perform(get("/v1/admin/ext-trackandtraceMapping")
                        .header("bnppuid", "h59900")
                        .param("query", "branchCode==30004;countryCode==FR"))
                .andExpect(status().isOk())
                .andExpect(content().json(mapper.writeValueAsString(mappings)));
    }

    @Test
    void testGetExternalTraceAndTrackMapping_shouldReturnEmptyListWhenNull() throws Exception {
        when(extTrackAndTraceMappingService.getMapping("branchCode==999")).thenReturn(null);

        mockMvc.perform(get("/v1/admin/ext-trackandtraceMapping")
                        .header("bnppuid", "h59900")
                        .param("query", "branchCode==999"))
                .andExpect(status().isOk())
                .andExpect(content().json("[]"));
    }
}


________



@ExtendWith(MockitoExtension.class)
class ExtTrackAndTraceMappingServiceImplTest {

    @Mock
    private ExtTrackAndTraceMappingRepository repository;

    @Mock
    private CommonMapper mapper;

    @Mock
    private ScoreCalculator calculator;

    @InjectMocks
    private ExtTrackAndTraceMappingServiceImpl service;

    @Test
    void testGetMapping_withValidQuery_shouldReturnTopPriorityMapping() {
        String query = "branchCode==30004;countryCode==FR;pgpeCode==ILCI;action==Validated;statusCst==Active";
        ExtTrackAndTraceMappingEntity entity = new ExtTrackAndTraceMappingEntity();
        List<ExtTrackAndTraceMappingEntity> entityList = List.of(entity);

        ExternalTrackAndTraceMapping mapped = new ExternalTrackAndTraceMapping();
        List<ExternalTrackAndTraceMapping> mappedList = List.of(mapped);

        when(repository.findAll(any(Specification.class))).thenReturn(entityList);
        when(mapper.getExtTrackAndTraceMappingModel(entityList)).thenReturn(mappedList);

        ExternalTrackAndTraceMapping result = service.getMapping(query);

        assertNotNull(result);
        assertEquals(mapped, result);
    }

    @Test
    void testGetMapping_withEmptyResult_shouldReturnNull() {
        when(repository.findAll(any(Specification.class))).thenReturn(Collections.emptyList());

        ExternalTrackAndTraceMapping result = service.getMapping("branchCode==999");
        assertNull(result);
    }
}



----------------package com.bnpparibas.dpw.service;

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity;
import com.bnpparibas.dpw.helpers.CustomComparator;
import com.bnpparibas.dpw.helpers.ScoreCalculator;
import com.bnpparibas.dpw.mapper.CommonMapper;
import com.bnpparibas.dpw.referential.model.ExternalTrackAndTraceMapping;
import com.bnpparibas.dpw.repository.ExtTrackAndTraceMappingRepository;
import com.bnpparibas.dpw.rsql.ParseUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;

@Slf4j
@Service
@RequiredArgsConstructor
public class ExtTrackAndTraceMappingServiceImpl implements ExtTrackAndTraceMappingService {

    private final ExtTrackAndTraceMappingRepository extTrackAndTraceMappingRepository;
    private final CommonMapper commonMapper;
    private final ScoreCalculator genericScoreCalculator;

    private static final List<String> fields = List.of(
            "transactionTypeCode",
            "subTransactionTypeCode",
            "productStatusCode",
            "transactionStatusCode"
    );

    @Override
    @Transactional(readOnly = true)
    public List<ExternalTrackAndTraceMapping> getMapping(String query) {
        log.info("[getMapping] RSQL query: {}", query);

        Specification<ExtTrackAndTraceMappingEntity> specification = ParseUtils.parseQuery(
                query,
                new HashMap<>(),
                ExtTrackAndTraceMappingEntity.class
        );

        List<ExtTrackAndTraceMappingEntity> entities = extTrackAndTraceMappingRepository.findAll(specification);

        if (entities.isEmpty()) {
            return Collections.emptyList();
        }

        List<ExternalTrackAndTraceMapping> models = commonMapper.getExtTrackAndTraceMappingModel(entities);

        Map<String, String> paramMap = extractParams(query);
        List<Object> values = fields.stream()
                .map(paramMap::get)
                .toList();

        PriorityQueue<ExternalTrackAndTraceMapping> queue =
                new PriorityQueue<>(new CustomComparator<>(fields, values, genericScoreCalculator));

        queue.addAll(models);

        // return the top result only as a list
        ExternalTrackAndTraceMapping bestMatch = queue.peek();
        return bestMatch != null ? List.of(bestMatch) : Collections.emptyList();
    }

    private Map<String, String> extractParams(String rsql) {
        Map<String, String> map = new HashMap<>();
        if (rsql != null && !rsql.isBlank()) {
            String[] conditions = rsql.split(";");
            for (String condition : conditions) {
                String[] parts = condition.split("==");
                if (parts.length == 2) {
                    map.put(parts[0].trim(), parts[1].trim());
                }
            }
        }
        return map;
    }
}
-------------
package com.bnpparibas.dpw.service.impl;

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity;
import com.bnpparibas.dpw.mapper.CommonMapper;
import com.bnpparibas.dpw.model.ExternalTrackAndTraceMapping;
import com.bnpparibas.dpw.repository.ExtTrackAndTraceMappingRepository;
import com.bnpparibas.dpw.service.ExtTrackAndTraceMappingService;
import com.bnpparibas.dpw.util.ParseUtils;
import com.bnpparibas.dpw.util.PrioritySelector;
import com.bnpparibas.dpw.util.SpecificationUtils;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
public class ExtTrackAndTraceMappingServiceImpl implements ExtTrackAndTraceMappingService {

    @Autowired
    private ExtTrackAndTraceMappingRepository repository;

    @Autowired
    private CommonMapper commonMapper;

    @Autowired
    private SpecificationUtils specificationUtils;

    @Autowired
    private PrioritySelector<ExtTrackAndTraceMappingEntity> prioritySelector;

    private static final List<String> wildcardSupportedFields = Arrays.asList(
            "transactionTypeCode", "subTransactionTypeCode",
            "productStatusCode", "transactionStatusCode"
    );

    @Override
    public List<ExternalTrackAndTraceMapping> getMapping(String query) {
        // Parse the RSQL query to a Map<String, Object>
        Map<String, Object> queryParams = ParseUtils.parseQuery(query, ExtTrackAndTraceMappingEntity.class);

        // Filter out wildcard-supported fields with "*" value
        Map<String, Object> baseParams = new HashMap<>(queryParams);
        wildcardSupportedFields.forEach(field -> {
            if ("*".equals(queryParams.get(field))) {
                baseParams.remove(field);
            }
        });

        // Build specification using mandatory + optional fields excluding wildcards
        Specification<ExtTrackAndTraceMappingEntity> specification =
                specificationUtils.build(baseParams, ExtTrackAndTraceMappingEntity.class);

        // Fetch all records matching the base specification
        List<ExtTrackAndTraceMappingEntity> allMatchedEntities = repository.findAll(specification);

        // Filter for best match using comparator logic and PrioritySelector
        ExtTrackAndTraceMappingEntity bestMatch =
                prioritySelector.getBestMatch(allMatchedEntities, queryParams, wildcardSupportedFields);

        if (bestMatch != null) {
            ExternalTrackAndTraceMapping mapped = commonMapper.convert(bestMatch, ExternalTrackAndTraceMapping.class);
            return List.of(mapped);
        }

        return Collections.emptyList();
    }
}




---------------------

package com.bnpparibas.dpw.service.impl;

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity;
import com.bnpparibas.dpw.mapper.CommonMapper;
import com.bnpparibas.dpw.model.ExternalTrackAndTraceMapping;
import com.bnpparibas.dpw.repository.ExtTrackAndTraceMappingRepository;
import com.bnpparibas.dpw.score.ScoreCalculator;
import com.bnpparibas.dpw.service.ExtTrackAndTraceMappingService;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import java.util.*;

@ExtendWith(MockitoExtension.class)
class ExtTrackAndTraceMappingServiceImplTest {

    @Mock
    private ExtTrackAndTraceMappingRepository repository;

    @Mock
    private CommonMapper commonMapper;

    @Mock
    private ScoreCalculator calculator;

    @InjectMocks
    private ExtTrackAndTraceMappingServiceImpl service;

    @Test
    void getMapping_shouldReturnHighestPriorityMatch() {
        // Sample entity and expected model
        ExtTrackAndTraceMappingEntity entity = new ExtTrackAndTraceMappingEntity();
        entity.setBranchCode("30004");

        ExternalTrackAndTraceMapping model = new ExternalTrackAndTraceMapping();
        model.setBranchCode("30004");

        List<ExtTrackAndTraceMappingEntity> entityList = List.of(entity);
        List<ExternalTrackAndTraceMapping> modelList = List.of(model);

        // Mocking behavior
        when(repository.findAll(any())).thenReturn(entityList);
        when(commonMapper.getExtTrackAndTraceMappingModel(entityList)).thenReturn(modelList);
        when(calculator.calculate(any(), any())).thenReturn(1); // all same score

        // Method call
        ExternalTrackAndTraceMapping result = service.getMapping(
                "30004", "FR", "ILCI", "Validated", "Active",
                null, null, "*", "*", "*", "*"
        );

        assertNotNull(result);
        assertEquals("30004", result.getBranchCode());
        verify(repository).findAll(any());
        verify(commonMapper).getExtTrackAndTraceMappingModel(entityList);
    }

    @Test
    void getMapping_shouldReturnNullIfNoData() {
        when(repository.findAll(any())).thenReturn(Collections.emptyList());

        ExternalTrackAndTraceMapping result = service.getMapping(
                "30004", "FR", "ILCI", "Validated", "Active",
                null, null, "*", "*", "*", "*"
        );

        assertNull(result);
    }
}



----------------------_______________________
package com.bnpparibas.dpw.service.impl;

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity;
import com.bnpparibas.dpw.mapper.CommonMapper;
import com.bnpparibas.dpw.model.ExternalTrackAndTraceMapping;
import com.bnpparibas.dpw.repository.ExtTrackAndTraceMappingRepository;
import com.bnpparibas.dpw.score.ScoreCalculator;
import com.bnpparibas.dpw.service.ExtTrackAndTraceMappingService;
import com.bnpparibas.dpw.util.ParseUtils;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.springframework.data.jpa.domain.Specification;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class ExtTrackAndTraceMappingServiceImplTest {

    @InjectMocks
    private ExtTrackAndTraceMappingServiceImpl service;

    @Mock
    private ExtTrackAndTraceMappingRepository repository;

    @Mock
    private CommonMapper commonMapper;

    @Mock
    private ScoreCalculator scoreCalculator;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testGetMapping_returnsCorrectMapping_whenMatchFound() {
        // Given
        String branchCode = "BR";
        String countryCode = "IN";
        String pgpeCode = "PG";
        String action = "CREATE";
        String statusCst = "ACTIVE";
        String statusCxt = "CTX";
        String prodCode = "PCODE";
        String txnType = "T1";
        String subTxnType = "ST1";
        String prodStatCode = "PSC";
        String txnStatCode = "TSC";

        List<ExtTrackAndTraceMappingEntity> mockEntities = List.of(new ExtTrackAndTraceMappingEntity());
        List<ExternalTrackAndTraceMapping> mockModels = List.of(new ExternalTrackAndTraceMapping().branchCode(branchCode));

        // Mock behavior
        Map<String, Object> queryParams = new HashMap<>();
        queryParams.put("branchCode", branchCode);
        queryParams.put("countryCode", countryCode);
        queryParams.put("pgpeCode", pgpeCode);
        queryParams.put("action", action);
        queryParams.put("statusCst", statusCst);
        queryParams.put("statusCxt", statusCxt);
        queryParams.put("prodCode", prodCode);
        queryParams.put("transactionTypeCode", txnType);
        queryParams.put("subTransactionTypeCode", subTxnType);
        queryParams.put("productStatusCode", prodStatCode);
        queryParams.put("transactionStatusCode", txnStatCode);

        Specification<ExtTrackAndTraceMappingEntity> spec = mock(Specification.class);
        when(ParseUtils.parseQuery(queryParams, ExtTrackAndTraceMappingEntity.class)).thenReturn(spec);
        when(repository.findAll(spec)).thenReturn(mockEntities);
        when(commonMapper.getExtTrackAndTraceMappingModel(mockEntities)).thenReturn(mockModels);

        // When
        ExternalTrackAndTraceMapping result = service.getMapping(
            branchCode, countryCode, pgpeCode, action, statusCst, statusCxt, prodCode, txnType, subTxnType, prodStatCode, txnStatCode
        );

        // Then
        assertNotNull(result);
        assertEquals(branchCode, result.getBranchCode());
    }

    @Test
    void testGetMapping_returnsNull_whenNoResults() {
        String branchCode = "BR";
        String countryCode = "IN";
        String pgpeCode = "PG";
        String action = "CREATE";
        String statusCst = "ACTIVE";

        Map<String, Object> queryParams = Map.of(
            "branchCode", branchCode,
            "countryCode", countryCode,
            "pgpeCode", pgpeCode,
            "action", action,
            "statusCst", statusCst
        );

        Specification<ExtTrackAndTraceMappingEntity> spec = mock(Specification.class);
        when(ParseUtils.parseQuery(queryParams, ExtTrackAndTraceMappingEntity.class)).thenReturn(spec);
        when(repository.findAll(spec)).thenReturn(Collections.emptyList());

        ExternalTrackAndTraceMapping result = service.getMapping(
            branchCode, countryCode, pgpeCode, action, statusCst, null, null, null, null, null, null
        );

        assertNull(result);
    }
}


_____________&___&___________

@Slf4j
@Service
@RequiredArgsConstructor
public class ExtTrackAndTraceMappingServiceImpl implements ExtTrackAndTraceMappingService {

    private final ExtTrackAndTraceMappingRepository extTrackAndTraceMappingRepository;
    private final CommonMapper commonMapper;
    private final ScoreCalculator genericScoreCalculator;

    private static final List<String> fields = List.of(
            "transactionTypeCode", 
            "subTransactionTypeCode", 
            "productStatusCode", 
            "transactionStatusCode"
    );

    @Override
    @Transactional(readOnly = true)
    public ExternalTrackAndTraceMapping getMapping(
            String branchCode,
            String countryCode,
            String pgpeCode,
            String action,
            String statusCst,
            String statusCxt,
            String prodCode,
            String transactionTypeCode,
            String subTransactionTypeCode,
            String productStatusCode,
            String transactionStatusCode) {

        log.info("[getMapping] Input params - branchCode: {}, countryCode: {}, pgpeCode: {}, action: {}, statusCst: {}, statusCxt: {}, prodCode: {}, txnTypeCode: {}, subTxnTypeCode: {}, prodStatusCode: {}, txnStatusCode: {}",
                branchCode, countryCode, pgpeCode, action, statusCst, statusCxt, prodCode, transactionTypeCode, subTransactionTypeCode, productStatusCode, transactionStatusCode);

        // Mandatory RSQL base
        StringBuilder rsql = new StringBuilder();
        rsql.append("branchCode==").append(branchCode).append(";");
        rsql.append("countryCode==").append(countryCode).append(";");
        rsql.append("pgpeCode==").append(pgpeCode).append(";");
        rsql.append("action==").append(action).append(";");
        rsql.append("statusCst==").append(statusCst);

        // Optional fields
        if (statusCxt != null) rsql.append(";statusCxt==").append(statusCxt);
        if (prodCode != null) rsql.append(";prodCode==").append(prodCode);

        // Wildcard-matching fields
        if (transactionTypeCode != null) rsql.append(";transactionTypeCode==").append(transactionTypeCode);
        if (subTransactionTypeCode != null) rsql.append(";subTransactionTypeCode==").append(subTransactionTypeCode);
        if (productStatusCode != null) rsql.append(";productStatusCode==").append(productStatusCode);
        if (transactionStatusCode != null) rsql.append(";transactionStatusCode==").append(transactionStatusCode);

        // Parse RSQL query
        Specification<ExtTrackAndTraceMappingEntity> specification = ParseUtils.parseQuery(
                rsql.toString(), 
                new HashMap<>(), 
                ExtTrackAndTraceMappingEntity.class
        );

        List<ExtTrackAndTraceMappingEntity> entities = extTrackAndTraceMappingRepository.findAll(specification);

        if (!entities.isEmpty()) {
            List<Object> values = Arrays.asList(transactionTypeCode, subTransactionTypeCode, productStatusCode, transactionStatusCode);

            PriorityQueue<ExternalTrackAndTraceMapping> queue =
                    new PriorityQueue<>(new CustomComparator<>(fields, values, genericScoreCalculator));

            queue.addAll(commonMapper.getExtTrackAndTraceMappingModel(entities));
            return queue.peek();
        }

        return null;
    }
}
------++++------------------++





package com.bnpparibas.dpw.service.impl;

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity;
import com.bnpparibas.dpw.mapper.CommonMapper;
import com.bnpparibas.dpw.model.ExternalTrackAndTraceMapping;
import com.bnpparibas.dpw.repository.ExtTrackAndTraceMappingRepository;
import com.bnpparibas.dpw.service.ExtTrackAndTraceMappingService;
import com.bnpparibas.dpw.util.CustomComparator;
import com.bnpparibas.dpw.util.ParseUtils;
import com.bnpparibas.dpw.util.ScoreCalculator;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;

import java.util.*;

@Slf4j
@Service
public class ExtTrackAndTraceMappingServiceImpl implements ExtTrackAndTraceMappingService {

    private final ExtTrackAndTraceMappingRepository extTrackAndTraceMappingRepository;
    private final CommonMapper commonMapper;
    private final ScoreCalculator genericScoreCalculator;

    private static final List<String> fields = List.of(
            "transactionTypeCode", "subTransactionTypeCode", "productStatusCode", "transactionStatusCode"
    );

    public ExtTrackAndTraceMappingServiceImpl(
            ExtTrackAndTraceMappingRepository extTrackAndTraceMappingRepository,
            CommonMapper commonMapper,
            ScoreCalculator genericScoreCalculator) {
        this.extTrackAndTraceMappingRepository = extTrackAndTraceMappingRepository;
        this.commonMapper = commonMapper;
        this.genericScoreCalculator = genericScoreCalculator;
    }

    @Override
    @Transactional
    public ExternalTrackAndTraceMapping getMapping(
            String branchCode,
            String countryCode,
            String pgpeCode,
            String action,
            String statusCst,
            String statusCxt,
            String prodCode,
            String transactionTypeCode,
            String subTransactionTypeCode,
            String productStatusCode,
            String transactionStatusCode) {

        log.info("[getMapping] inside the getMapping with branchCode {}, countryCode {}, pgpeCode {}, action {}, statusCst {}",
                branchCode, countryCode, pgpeCode, action, statusCst);

        Map<String, Object> queryParams = new HashMap<>();
        queryParams.put("branchCode", branchCode);
        queryParams.put("countryCode", countryCode);
        queryParams.put("pgpeCode", pgpeCode);
        queryParams.put("action", action);
        queryParams.put("statusCst", statusCst);

        if (statusCxt != null) queryParams.put("statusCxt", statusCxt);
        if (prodCode != null) queryParams.put("prodCode", prodCode);

        // Prepare wildcard filtering fields (optional ones)
        if (transactionTypeCode != null) queryParams.put("transactionTypeCode", transactionTypeCode);
        if (subTransactionTypeCode != null) queryParams.put("subTransactionTypeCode", subTransactionTypeCode);
        if (productStatusCode != null) queryParams.put("productStatusCode", productStatusCode);
        if (transactionStatusCode != null) queryParams.put("transactionStatusCode", transactionStatusCode);

        // Create Specification from ParseUtils (already available in project)
        Specification<ExtTrackAndTraceMappingEntity> spec =
                ParseUtils.parseQuery(queryParams, ExtTrackAndTraceMappingEntity.class);

        List<ExtTrackAndTraceMappingEntity> resultEntities =
                extTrackAndTraceMappingRepository.findAll(spec);

        if (resultEntities.isEmpty()) {
            log.info("No result found for the given criteria.");
            return null;
        }

        List<ExternalTrackAndTraceMapping> models =
                commonMapper.getExtTrackAndTraceMappingModel(resultEntities);

        List<Object> priorityValues = Arrays.asList(
                transactionTypeCode,
                subTransactionTypeCode,
                productStatusCode,
                transactionStatusCode
        );

        PriorityQueue<ExternalTrackAndTraceMapping> pq =
                new PriorityQueue<>(new CustomComparator<>(fields, priorityValues, genericScoreCalculator));

        pq.addAll(models);
        return pq.peek();
    }
}

-----------

package com.bnpparibas.dpw.referential.controller;

import com.bnpparibas.dpw.referential.api.StaticDataApi;
import com.bnpparibas.dpw.referential.model.ExternalTrackAndTraceMapping;
import com.bnpparibas.dpw.referential.service.ExtTrackAndTraceMappingService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;

import java.util.Collections;
import java.util.List;

@Slf4j
@RestController
@RequiredArgsConstructor
public class StaticDataController implements StaticDataApi {

    private final ExtTrackAndTraceMappingService extTrackAndTraceMappingService;

    @Override
    public ResponseEntity<List<ExternalTrackAndTraceMapping>> getExternalTraceAndTrackMapping(
            String bnppuid,
            String branchCode,
            String countryCode,
            String pgpeCode,
            String action,
            String statusCst,
            String statusCxt,
            String prodCode,
            String transactionTypeCode,
            String subTransactionTypeCode,
            String productStatusCode,
            String transactionStatusCode) {

        log.info("[getExternalTraceAndTrackMapping] Requested with branchCode={}, countryCode={}, pgpeCode={}, action={}, statusCst={}",
                branchCode, countryCode, pgpeCode, action, statusCst);

        ExternalTrackAndTraceMapping mapping = extTrackAndTraceMappingService.getMapping(
                branchCode, countryCode, pgpeCode, action, statusCst, statusCxt,
                prodCode, transactionTypeCode, subTransactionTypeCode, productStatusCode, transactionStatusCode
        );

        return mapping == null
                ? ResponseEntity.ok(Collections.emptyList())
                : ResponseEntity.ok(List.of(mapping));
    }
}

--------------------------------------
// Test for ServiceImpl package com.bnpparibas.dpw.service;

import com.bmpparibas.dpw.entity.ExtTrackAndTraceMappingEntity; import com.bmpparibas.dpw.mapper.CommonMapper; import com.bmpparibas.dpw.referential.model.ExtTrackAndTraceMapping; import com.bmpparibas.dpw.repository.ExtTrackAndTraceMappingRepository; import com.bmpparibas.dpw.util.ScoreCalculator; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.MockitoAnnotations;

import java.util.Collections; import java.util.List;

import static org.junit.jupiter.api.Assertions.; import static org.mockito.Mockito.;

public class ExtTrackAndTraceMappingServiceImplTest {

@Mock
private ExtTrackAndTraceMappingRepository repository;

@Mock
private CommonMapper commonMapper;

@Mock
private ScoreCalculator scoreCalculator;

@InjectMocks
private ExtTrackAndTraceMappingServiceImpl service;

@BeforeEach
public void setup() {
    MockitoAnnotations.openMocks(this);
}

@Test
void testGetMapping_ReturnsBestMatch() {
    ExtTrackAndTraceMappingEntity entity = new ExtTrackAndTraceMappingEntity();
    ExtTrackAndTraceMapping model = new ExtTrackAndTraceMapping();

    when(repository.getextMapping(any(), any(), any(), any(), any(), any(), any()))
            .thenReturn(List.of(entity));
    when(commonMapper.getExtTrackAndTraceMappingModel(any()))
            .thenReturn(List.of(model));

    ExtTrackAndTraceMapping result = service.getMapping("30004", "FR", "ILCI", "Validated", "Active", null, null, null, null);
    assertNotNull(result);
}

@Test
void testGetMapping_ReturnsNullIfEmpty() {
    when(repository.getextMapping(any(), any(), any(), any(), any(), any(), any()))
            .thenReturn(Collections.emptyList());

    ExtTrackAndTraceMapping result = service.getMapping("30004", "FR", "ILCI", "Validated", "Active", null, null, null, null);
    assertNull(result);
}

}

// Test for Controller package com.bnpparibas.dpw.controller;

import com.bmpparibas.dpw.referential.model.ExtTrackAndTraceMapping; import com.bnpparibas.dpw.service.ExtTrackAndTraceMappingService; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import org.springframework.http.ResponseEntity;

import java.util.List;

import static org.junit.jupiter.api.Assertions.; import static org.mockito.Mockito.;

public class StaticDataControllerTest {

@Mock
private ExtTrackAndTraceMappingService service;

@InjectMocks
private StaticDataController controller;

@BeforeEach
public void setup() {
    MockitoAnnotations.openMocks(this);
}

@Test
void testGetExtTraceAndTrackMapping_Found() {
    ExtTrackAndTraceMapping mapping = new ExtTrackAndTraceMapping();
    when(service.getMapping(any(), any(), any(), any(), any(), any(), any(), any(), any()))
            .thenReturn(mapping);

    ResponseEntity<List<ExtTrackAndTraceMapping>> response =
            controller.getExtTraceAndTrackMapping("uid", "30004", "FR", "ILCI", "Validated", "Active", null, null, null);

    assertEquals(200, response.getStatusCodeValue());
    assertEquals(1, response.getBody().size());
}

@Test
void testGetExtTraceAndTrackMapping_NotFound() {
    when(service.getMapping(any(), any(), any(), any(), any(), any(), any(), any(), any()))
            .thenReturn(null);

    ResponseEntity<List<ExtTrackAndTraceMapping>> response =
            controller.getExtTraceAndTrackMapping("uid", "30004", "FR", "ILCI", "Validated", "Active", null, null, null);

    assertEquals(200, response.getStatusCodeValue());
    assertTrue(response.getBody().isEmpty());
}

}

// Repository Test (optional integration with H2, not covered here due to complexity) // Usually tested indirectly via Service integration tests









-----------------------------------------------

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface ExtTrackAndTraceMappingRepository extends DpwAppRepository<ExtTrackAndTraceMappingEntity, Long> {

    @Query("SELECT e FROM ExtTrackAndTraceMappingEntity e " +
           "WHERE e.branchCode = :branchCode " +
           "AND e.countryCode = :countryCode " +
           "AND e.pgpeCode = :pgpeCode " +
           "AND e.action = :action " +
           "AND UPPER(e.statusCst) = UPPER(:statusCst) " +
           "AND (:statusCxt IS NULL OR e.statusCxt = :statusCxt) " +
           "AND (:prodCode IS NULL OR e.productCode = :prodCode)")
    List<ExtTrackAndTraceMappingEntity> findMatchingMappings(
        @Param("branchCode") String branchCode,
        @Param("countryCode") String countryCode,
        @Param("pgpeCode") String pgpeCode,
        @Param("action") String action,
        @Param("statusCst") String statusCst,
        @Param("statusCxt") String statusCxt,
        @Param("prodCode") String prodCode
    );
}













@Query("SELECT e FROM ExtTrackAndTraceMappingEntity e " +
       "WHERE e.branchCode = :branchCode " +
       "AND e.countryCode = :countryCode " +
       "AND e.pgpeCode = :pgpeCode " +
       "AND e.action = :action " +
       "AND UPPER(e.statusCst) = UPPER(:statusCst) " +
       "AND (:statusCxt IS NULL OR e.statusCxt = :statusCxt) " +
       "AND (:prodCode IS NULL OR e.productCode = :prodCode)")
List<ExtTrackAndTraceMappingEntity> findMappings(
    @Param("branchCode") String branchCode,
    @Param("countryCode") String countryCode,
    @Param("pgpeCode") String pgpeCode,
    @Param("action") String action,
    @Param("statusCst") String statusCst,
    @Param("statusCxt") String statusCxt,
    @Param("prodCode") String prodCode
);




!!!!!!!!!!!!!!!!!!!// ExtTrackAndTraceMappingServiceImplTest.java

import static org.junit.jupiter.api.Assertions.; import static org.mockito.BDDMockito.;

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity; import com.bnpparibas.dpw.repository.ExtTrackAndTraceMappingRepository; import com.bnpparibas.dpw.service.impl.ExtTrackAndTraceMappingServiceImpl; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Optional;

@ExtendWith(MockitoExtension.class) public class ExtTrackAndTraceMappingServiceImplTest {

@Mock
private ExtTrackAndTraceMappingRepository repository;

@InjectMocks
private ExtTrackAndTraceMappingServiceImpl service;

private ExtTrackAndTraceMappingEntity entity;

@BeforeEach
public void setup() {
    entity = new ExtTrackAndTraceMappingEntity();
    entity.setId(3L);
    entity.setBranchCode("30004");
    entity.setCountryCode("FR");
    entity.setPgpeCode("ILCI");
    entity.setAction("Validated");
    entity.setStatusCst("Active");
    entity.setStatusCxt("AC");
    entity.setProductCode("IC");
    entity.setTransactionTypeCode("TTC");
}

@Test
public void testGetMapping_Found() {
    given(repository.findByBranchCodeAndCountryCodeAndPgpeCodeAndActionAndStatusCst(
            "30004", "FR", "ILCI", "Validated", "Active"))
            .willReturn(entity);

    Optional<ExtTrackAndTraceMappingEntity> result = service.getMapping("30004", "FR", "ILCI", "Validated", "Active");

    assertTrue(result.isPresent());
    ExtTrackAndTraceMappingEntity actual = result.get();

    // Mandatory fields not null
    assertNotNull(actual.getBranchCode());
    assertNotNull(actual.getCountryCode());
    assertNotNull(actual.getPgpeCode());
    assertNotNull(actual.getAction());
    assertNotNull(actual.getStatusCst());

    // All fields value check
    assertEquals("30004", actual.getBranchCode());
    assertEquals("FR", actual.getCountryCode());
    assertEquals("ILCI", actual.getPgpeCode());
    assertEquals("Validated", actual.getAction());
    assertEquals("Active", actual.getStatusCst());
    assertEquals("AC", actual.getStatusCxt());
    assertEquals("IC", actual.getProductCode());
    assertEquals("TTC", actual.getTransactionTypeCode());
}

@Test
public void testGetMapping_NotFound() {
    given(repository.findByBranchCodeAndCountryCodeAndPgpeCodeAndActionAndStatusCst(
            "30004", "FR", "ILCI", "Validated", "Active"))
            .willReturn(null);

    Optional<ExtTrackAndTraceMappingEntity> result = service.getMapping("30004", "FR", "ILCI", "Validated", "Active");

    assertTrue(result.isEmpty());
}

}



--------------

package com.bnpparibas.dpw.service;

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity;
import com.bnpparibas.dpw.service.impl.ExtTrackAndTraceMappingServiceImpl;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

public class ExtTrackAndTraceMappingServiceTest {

    @Mock
    private ExtTrackAndTraceMappingService service;

    @Test
    public void testGetMappingReturnsExpectedEntity() {
        ExtTrackAndTraceMappingEntity expectedEntity = new ExtTrackAndTraceMappingEntity();
        expectedEntity.setBranchCode("30004");
        expectedEntity.setCountryCode("FR");
        expectedEntity.setPgpeCode("ILCI");
        expectedEntity.setAction("Validated");
        expectedEntity.setStatusCst("Active");

        when(service.getMapping("30004", "FR", "ILCI", "Validated", "Active"))
            .thenReturn(Optional.of(expectedEntity));

        Optional<ExtTrackAndTraceMappingEntity> actual = service.getMapping("30004", "FR", "ILCI", "Validated", "Active");

        assertEquals(expectedEntity.getBranchCode(), actual.get().getBranchCode());
    }
}













--------------------------

INSERT INTO DPW_EXT_TRACK_TRACE_MAPPING (
    ID, BRANCH_CODE, COUNTRY_CODE, PGPE_CODE, ACTION, STATUS_CST, STATUS_CXT, PROD_CODE, TRANSACTION_TYPE_CODE
) VALUES (
    1, '3000', 'FR', 'ILCI', 'Validated', 'Active', 'AC', 'IC', 'T1'
);

INSERT INTO DPW_EXT_TRACK_TRACE_MAPPING (
    ID, BRANCH_CODE, COUNTRY_CODE, PGPE_CODE, ACTION, STATUS_CST, STATUS_CXT, PROD_CODE, TRANSACTION_TYPE_CODE
) VALUES (
    2, '3001', 'IN', 'ILCI', 'Rejected', 'Inactive', 'IN', 'IC', 'T2'
);

INSERT INTO DPW_EXT_TRACK_TRACE_MAPPING (
    ID, BRANCH_CODE, COUNTRY_CODE, PGPE_CODE, ACTION, STATUS_CST, STATUS_CXT, PROD_CODE, TRANSACTION_TYPE_CODE
) VALUES (
    3, '3002', 'US', 'ILC2', 'Pending', 'OnHold', 'OH', NULL, NULL
);





// models/claim.model.ts
import { Policy } from './policy.model';

export interface Claim {
  id: number;
  claimAmount: number;
  claimType: string;
  status: string;
  policy: Policy;
}

___________________________________________________________________________________________________

// models/policy.model.ts
export interface Policy {
  policyHolderName: string;
  planType: string;
  insuredAmount: number;
  tenure: number;
  premiumFrequency: string;
  policyStatus: string;
}

__________________________________________________________________________________________________________
// approve-claim.component.ts
import { Component, OnInit } from '@angular/core';
import { ClaimService } from '../authservice/claim.service';
import { Router } from '@angular/router';
import { Claim } from '../models/claim.model';

@Component({
  selector: 'app-approve-claim',
  templateUrl: './claim-approval.component.html',
  styleUrls: ['./claim-approval.component.css']
})
export class ApproveClaimComponent implements OnInit {
  pendingClaims: Claim[] = [];
  errorMessage: string = "";

  constructor(private claimService: ClaimService, private router: Router) {}

  ngOnInit(): void {
    this.fetchPendingClaims();
  }

  fetchPendingClaims(): void {
    this.claimService.getClaimsForApproval().subscribe({
      next: claims => this.pendingClaims = claims,
      error: err => this.errorMessage = 'Error loading pending claims'
    });
  }

  approveClaim(claimId: number): void {
    this.claimService.approveClaim(claimId).subscribe({
      next: () => this.fetchPendingClaims(),
      error: err => console.error('Error approving claim', err)
    });
  }

  rejectClaim(claimId: number): void {
    this.claimService.rejectClaim(claimId).subscribe({
      next: () => this.fetchPendingClaims(),
      error: err => console.error('Error rejecting claim', err)
    });
  }
}
_____________________________________________________________________________________________________________________

<div class="approve-container">
  <h2>Pending Claims for Approval</h2>

  <div *ngIf="errorMessage" class="error">{{ errorMessage }}</div>

  <table *ngIf="pendingClaims.length > 0" class="claim-table">
    <thead>
      <tr>
        <th>Claim ID</th>
        <th>Claim Amount</th>
        <th>Type</th>
        <th>Status</th>
        <th>Policy Details</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
      <tr *ngFor="let claim of pendingClaims">
        <td>{{ claim.id }}</td>
        <td>{{ claim.claimAmount }}</td>
        <td>{{ claim.claimType }}</td>
        <td>{{ claim.status }}</td>
        <td>
          <div *ngIf="claim.policy">
            <p><strong>Holder Name:</strong> {{ claim.policy.policyHolderName }}</p>
            <p><strong>Plan Type:</strong> {{ claim.policy.planType }}</p>
            <p><strong>Insured Amount:</strong> â‚¹{{ claim.policy.insuredAmount }}</p>
            <p><strong>Tenure:</strong> {{ claim.policy.tenure }} years</p>
            <p><strong>Premium Frequency:</strong> {{ claim.policy.premiumFrequency }}</p>
            <p><strong>Status:</strong> {{ claim.policy.policyStatus }}</p>
          </div>
        </td>
        <td>
          <button (click)="approveClaim(claim.id)" class="btn-approve">Approve</button>
          <button (click)="rejectClaim(claim.id)" class="btn-reject">Reject</button>
        </td>
      </tr>
    </tbody>
  </table>

  <div *ngIf="pendingClaims.length === 0">No pending claims to display.</div>
</div>
_________________________________________________________________________________________________________

@Configuration
public class OrikaMapperConfig {

    @Bean
    public MapperFactory mapperFactory() {
        MapperFactory factory = new DefaultMapperFactory.Builder().build();
        factory.classMap(User.class, UserDTO.class)
                .byDefault()
                .register();
        return factory;
    }

    @Bean
    public MapperFacade mapperFacade(MapperFactory mapperFactory) {
        return mapperFactory.getMapperFacade();
    }
}
____________________________________________________________________________________________________________________

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final MapperFacade mapper;

    @Override
    public UserDTO createUser(UserDTO userDTO){
        User user = mapper.map(userDTO, User.class);
        return mapper.map(userRepository.save(user), UserDTO.class);
    }

    @Override
    public UserDTO getUserById(Long id) {
        User user = userRepository.findById(id).orElseThrow(() -> new RuntimeException("User not found"));
        return mapper.map(user, UserDTO.class);
    }

    @Override
    public UserDTO updateUser(Long id, UserDTO userDTO) {
        User existingUser = userRepository.findById(id).orElseThrow(() -> new RuntimeException("User not found"));

        existingUser.setUsername(userDTO.getUsername());
        existingUser.setPassword(userDTO.getPassword());
        existingUser.setRole(userDTO.getRole());

        return mapper.map(userRepository.save(existingUser), UserDTO.class);
    }

    @Override
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }

    @Override
    public List<UserDTO> getAllUsers() {
        return userRepository.findAll()
                .stream()
                .map(user -> mapper.map(user, UserDTO.class))
                .collect(Collectors.toList());
    }

    @Override
    public UserDTO validateUser(String username, String password) {
        Optional<User> userOpt = userRepository.findByUsernameAndPassword(username, password);
        return userOpt.map(user -> mapper.map(user, UserDTO.class)).orElse(null);
    }
}
__________________________________________________________________________________

public interface UserService {

    UserDTO createUser(UserDTO userDTO);

    UserDTO getUserById(Long id);

    UserDTO updateUser(Long id, UserDTO userDTO);

    void deleteUser(Long id);

    List<UserDTO> getAllUsers();

    UserDTO validateUser(String username, String password);
}


----------------------------------------------------------------------------------------------------------------------------------

@RestController
@CrossOrigin(origins = "http://localhost:4200")
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @PostMapping("/login")
    public ResponseEntity<?> loginUser(@RequestBody UserDTO userDTO) {
        UserDTO user = userService.validateUser(userDTO.getUsername(), userDTO.getPassword());
        if (user != null) {
            return ResponseEntity.ok(user);
        } else {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid credentials");
        }
    }

    @PostMapping("/register")
    public ResponseEntity<UserDTO> createUser(@RequestBody UserDTO userDTO) {
        return ResponseEntity.ok(userService.createUser(userDTO));
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserDTO> getUserById(@PathVariable Long id) {
        return ResponseEntity.ok(userService.getUserById(id));
    }

    @GetMapping("/")
    public ResponseEntity<List<UserDTO>> getAllUsers() {
        return ResponseEntity.ok(userService.getAllUsers());
    }

    @PutMapping("/{id}")
    public ResponseEntity<UserDTO> updateUser(@PathVariable long id, @RequestBody UserDTO userDTO) {
        return ResponseEntity.ok(userService.updateUser(id, userDTO));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable long id) {
        userService.deleteUser(id);
        return ResponseEntity.ok().build();
    }
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++











