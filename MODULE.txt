public static ExternalTNTRequest toExternalTNTRequest(
        ExternalTrackAndTraceMapping mapping,
        RequestExtended request,
        RequestEvent event) {

    if (mapping == null || request == null) return null;

    ExternalTNTRequest req = new ExternalTNTRequest();

    // Core mapping
    req.setBranchCode(request.getBranchCode());
    req.setCountryCode(request.getCountryCode());
    req.setEventId(event != null ? event.getId() : request.getEventId());
    req.setConnexisRequestRefId(request.getConnexisRequestRefId());
    req.setConnexisRequestTnxId(request.getConnexisRequestTnxId());
    req.setEbCusId(request.getEbCusId());
    req.setEbBanId(request.getEbBanId());

    // Event details
    if (event != null) {
        req.setHfr(event.getMfr());
        req.setUmfr(event.getUmfr());
        req.setLivr(event.getLivr());
        req.setEventCreationDateTime(event.getSystemCreationDate() != null 
            ? event.getSystemCreationDate() 
            : LocalDateTime.now());
        req.setTnxAmt(event.getAmount());
        req.setCurCode(event.getCurCode());
        req.setCounterPartyName(event.getCounterPartyCountry());
        req.setCustomerRef(event.getCustomerRef());
    }

    // Mapping codes
    req.setTnxTypeCode(request.getTnxTypeCode() != null ? request.getTnxTypeCode() : mapping.getTnxTypeCode());
    req.setSubTnxTypeCode(request.getSubTnxTypeCode() != null ? request.getSubTnxTypeCode() : mapping.getSubTnxTypeCode());
    req.setProdStatCode(request.getProdStatCode() != null ? request.getProdStatCode() : mapping.getProdStatCode());
    req.setTnxStatCode(mapping.getTnxStatCode());
    req.setSubTnxStatCode(mapping.getStatusCxt());
    req.setBoStatusUpdate(mapping.getStatusCxt() != null ? "Y" : "N");
    req.setProdCode(request.getProdCode() != null ? request.getProdCode() : mapping.getProdCode());
    req.setStatusCxt(mapping.getStatusCxt());

    // Optional fields
    req.setDocReceptionBankDate(request.getDocReceptionBankDate());
    req.setEventPriority(request.getEventPriority());
    req.setIncomingFilename(request.getIncomingFilename());
    req.setTargetCurrency(request.getTargetCurrency());
    req.setMessageTypeId(event != null ? event.getMessageTypeId() : null);
    req.setSenderRequestNumber(event != null ? event.getSenderRequestNumber() : null);

    return req;
}

-------------

public static ExternalTNTRequest toExternalTNTRequest(
        ExternalTrackAndTraceMapping mapping,
        Request request,
        RequestEvent event
) {
    if (mapping == null || request == null) {
        return null;
    }

    ExternalTNTRequest req = new ExternalTNTRequest();

    // ---- Basic request + event IDs ----
    req.setBranchCode(request.getBranchCode());
    req.setCountryCode(request.getCountryCode());

    // Prefer request.getEventId(), fallback to event.getId()
    req.setEventId(
            request.getEventId() != null ? request.getEventId()
                    : (event != null ? event.getId() : null)
    );

    // Prefer request values, fallback to event
    req.setConnexisRequestRefId(
            request.getConnexisRequestRefId() != null ? request.getConnexisRequestRefId()
                    : (event != null ? event.getConnexisRequestRefId() : null)
    );
    req.setConnexisRequestTnxId(
            request.getConnexisRequestTnxId() != null ? request.getConnexisRequestTnxId()
                    : (event != null ? event.getConnexisRequestTnxId() : null)
    );

    // ---- Party details ----
    if (event != null) {
        req.setMfr(event.getMfr());
        req.setUmfr(event.getUmfr());
        req.setLivr(event.getLivr());
    }

    req.setEbBanId(request.getEbBanId());
    req.setEbCusId(request.getEbCusId());

    // ---- Transaction codes ----
    req.setTnxTypeCode(
            request.getTnxTypeCode() != null ? request.getTnxTypeCode() : mapping.getTnxTypeCode()
    );
    req.setSubTnxTypeCode(
            request.getSubTnxTypeCode() != null ? request.getSubTnxTypeCode() : mapping.getSubTnxTypeCode()
    );
    req.setProdStatCode(
            request.getProdStatCode() != null ? request.getProdStatCode() : mapping.getProdStatCode()
    );
    req.setTnxStatCode(
            request.getTnxStatCode() != null ? request.getTnxStatCode() : mapping.getTnxStatCode()
    );
    req.setSubTnxStatCode(mapping.getStatusCxt());  // mapping drives this

    // ---- Status handling ----
    req.setBoStatusUpdate("Y"); // fixed flag (based on your XML output)
    req.setStatusCxt(mapping.getStatusCxt());

    // ---- Product code ----
    req.setProdCode(
            request.getProdCode() != null ? request.getProdCode() : mapping.getProdCode()
    );

    // ---- Dates ----
    req.setEventCreationDateTime(
            event != null && event.getSystemCreationDate() != null
                    ? event.getSystemCreationDate()
                    : LocalDateTime.now()
    );

    // ---- Amount & Currency ----
    if (event != null) {
        req.setTnxAmt(event.getAmount());
        req.setCurCode(event.getCurCode());
        req.setCounterPartyName(event.getCounterPartyCountry());
    }

    return req;
}





-----------------
package com.example.helper;

import com.example.model.ExternalTNTRequest;
import com.example.entity.ExtTrackAndTraceMapping;
import com.example.entity.RequestEvent;
import com.example.entity.RequestExtended;
import com.example.entity.Request;

import java.time.LocalDateTime;

public class CXTHelper {

    private CXTHelper() {
        // Utility class
    }

    public static ExternalTNTRequest toExternalTNTRequest(
            ExtTrackAndTraceMapping mapping,
            RequestEvent event,
            RequestExtended requestExtended,
            Request request
    ) {
        ExternalTNTRequest req = new ExternalTNTRequest();

        /* ========= 1. Mapping fields ========= */
        if (mapping != null) {
            req.setBranchCode(mapping.getBranchCode());
            req.setCountryCode(mapping.getCountryCode());
            req.setProdCode(mapping.getProdCode());
            req.setTnxTypeCode(mapping.getTxnTypeCode());
            req.setSubTnxTypeCode(mapping.getSubTxnTypeCode());
            req.setProdStatCode(mapping.getProdStatCode());
            req.setTnxStatCode(mapping.getTnxStatCode());
            req.setSubTnxStatCode(mapping.getSubTnxStatCode());
            req.setBoStatusUpdate(mapping.getBoStatusUpdate());
            req.setStatusCxt(mapping.getStatusCxt());
        }

        /* ========= 2. Event fields ========= */
        if (event != null) {
            req.setEventId(event.getId());
            req.setAfr(event.getAfr());
            req.setUmfr(event.getUmfr());
            req.setLivr(event.getLivr());

            // Dates
            req.setEventCreationDateTime(
                event.getSystemCreationDate() != null ? event.getSystemCreationDate() : LocalDateTime.now()
            );

            // Financial
            req.setTnxAmt(event.getAmount());
            req.setCurCode(event.getCurCode());

            // Parties
            req.setCounterPartyName(event.getCusName());
            req.setCustomerId(event.getCustMstNo());
        }

        /* ========= 3. Request Extended fields ========= */
        if (requestExtended != null) {
            req.setConnexisRequestRefId(requestExtended.getCustomerRef());
            req.setConnexisRequestTnxId(requestExtended.getConnexisTransactionId());
            req.setEbCusId(requestExtended.getEbCusId());
            req.setEbBanId(requestExtended.getEbBanId());
        }

        /* ========= 4. Request fields ========= */
        if (request != null) {
            // Any additional request-level fields
            if (request.getConnexisRequestRefId() != null) {
                req.setConnexisRequestRefId(request.getConnexisRequestRefId());
            }
            if (request.getConnexisRequestTnxId() != null) {
                req.setConnexisRequestTnxId(request.getConnexisRequestTnxId());
            }
            if (request.getEbCusId() != null) {
                req.setEbCusId(request.getEbCusId());
            }
            if (request.getEbBanId() != null) {
                req.setEbBanId(request.getEbBanId());
            }
        }

        return req;
    }
}
------------------


public class CXTHelper {

    private CXTHelper() {}

    public static ExternalTNTRequest toExternalTNTRequest(
            ExternalTrackAndTraceMapping mapping,
            Request request,
            RequestEvent event) {

        if (mapping == null || request == null) return null;

        ExternalTNTRequest req = new ExternalTNTRequest();

        req.setBranchCode(request.getBranchCode());
        req.setCountryCode(request.getCountryCode());

        // event id
        req.setEventId(request.getEventId() != null
                ? request.getEventId()
                : (event != null ? event.getId() : null));

        // reference ids
        req.setConnexisRequestRefId(
                request.getConnexisRequestRefId() != null
                        ? request.getConnexisRequestRefId()
                        : (event != null ? event.getConnexisRequestRefId() : null));
        req.setConnexisRequestTnxId(
                request.getConnexisRequestTnxId() != null
                        ? request.getConnexisRequestTnxId()
                        : (event != null ? event.getConnexisRequestTnxId() : null));

        // identifiers from event
        if (event != null) {
            req.setMfr(event.getMfr());
            req.setUmfr(event.getUmfr());
            req.setLivr(event.getLivr());
        }

        req.setEbBanId(request.getEbBanId());
        req.setEbCusId(request.getEbCusId());

        // mapping fallbacks
        req.setTnxTypeCode(
                request.getTnxTypeCode() != null ? request.getTnxTypeCode() : mapping.getTnxTypeCode());
        req.setSubTnxTypeCode(
                request.getSubTnxTypeCode() != null ? request.getSubTnxTypeCode() : mapping.getSubTnxTypeCode());
        req.setProdStatCode(
                request.getProdStatCode() != null ? request.getProdStatCode() : mapping.getProdStatCode());
        req.setTnxStatCode(mapping.getTnxStatCode());

        // derived values
        req.setSubTnxStatCode(mapping.getStatusCxt());
        req.setBoStatusUpdate(mapping.getStatusCxt() != null ? "Y" : "N");

        req.setProdCode(
                request.getProdCode() != null ? request.getProdCode() : mapping.getProdCode());

        // creation datetime
        LocalDateTime creationDate = (request.getConnexisRequestRefId() == null)
                ? (event != null && event.getSystemCreationDate() != null
                    ? event.getSystemCreationDate()
                    : LocalDateTime.now())
                : null;
        req.setEventCreationDateTime(creationDate);

        // amount + currency
        if (request.getConnexisRequestRefId() == null && event != null) {
            req.setTnxAmt(event.getAmount());
            req.setCurCode(event.getCurCode());
            req.setCounterPartyName(event.getCounterPartyCountry());
        }

        // status cxt straight from mapping
        req.setStatusCxt(mapping.getStatusCxt());

        return req;
    }
}



---------------------------------------


public class CXTHelper {

    private CXTHelper() {}

    public static ExternalTNTRequest toExternalTNTRequest(
            ExternalTrackAndTraceMapping mapping,
            RequestEvent event) {

        if (mapping == null) return null;

        ExternalTNTRequest req = new ExternalTNTRequest();

        // --- From Mapping ---
        req.setBranchCode(mapping.getBranchCode());
        req.setCountryCode(mapping.getCountryCode());
        req.setStatusCxt(mapping.getStatusCxt());
        req.setProdCode(mapping.getProdCode());
        req.setTnxTypeCode(mapping.getTnxTypeCode());
        req.setSubTnxTypeCode(mapping.getSubTnxTypeCode());
        req.setProdStatCode(mapping.getProdStatCode());
        req.setTnxStatCode(mapping.getTnxStatCode());
        req.setSubTnxStatCode(mapping.getSubTnxStatCode());
        req.setBoStatusUpdate(mapping.getBoStatusUpdate());

        // --- From Event ---
        if (event != null) {
            req.setEventId(event.getId());
            req.setMfr(event.getMfr());
            req.setUmfr(event.getUmfr());
            req.setLivr(event.getLivr());

            req.setConnexisRequestRefId(event.getConnexisRequestRefId());
            req.setConnexisRequestTnxId(event.getConnexisRequestTnxId());

            req.setEbCusId(event.getEbCusId());
            req.setEbBanId(event.getEbBanId());

            // Event creation timestamp
            req.setEventCreationDateTime(
                event.getSystemCreationDate() != null
                        ? event.getSystemCreationDate()
                        : LocalDateTime.now()
            );

            // Optional: map financials if available
            req.setTnxAmt(event.getAmount());
            req.setCurCode(event.getCurCode());
        }

        return req;
    }
}







-------------------


public class CXTHelper {

    private CXTHelper() {}

    public static ExternalTNTRequest toExternalTNTRequest(
            ExternalTrackAndTraceMapping mapping,
            Request createdRequest) {

        if (mapping == null) {
            return null;
        }

        ExternalTNTRequest req = new ExternalTNTRequest();

        // --- From Mapping ---
        req.setBranchCode(mapping.getBranchCode());
        req.setCountryCode(mapping.getCountryCode());
        req.setStatusCxt(mapping.getStatusCxt());
        req.setProdCode(mapping.getProdCode());
        req.setTnxTypeCode(mapping.getTnxTypeCode());
        req.setSubTnxTypeCode(mapping.getSubTnxTypeCode());
        req.setProdStatCode(mapping.getProdStatCode());
        req.setTnxStatCode(mapping.getTnxStatCode());

        // --- From Request (event details) ---
        if (createdRequest != null && createdRequest.getEvent() != null) {
            req.setEventId(createdRequest.getEvent().getId());

            if (createdRequest.getEvent().getSystemCreationDate() != null) {
                req.setEventCreationDateTime(createdRequest.getEvent().getSystemCreationDate());
            } else {
                req.setEventCreationDateTime(LocalDateTime.now());
            }
        }

        // --- Additional fields from Request (enrichment) ---
        if (createdRequest != null) {
            // Applicant / company / beneficiary data
            req.setCounterPartyName(createdRequest.getApplicantAbbvName());   // map applicant name
            req.setCustomerId(createdRequest.getBeneficiaryName());           // map beneficiary name

            // Amounts and currency
            if (createdRequest.getTransactionDetails() != null) {
                req.setTnxAmt(createdRequest.getTransactionDetails().getTnxAmt());
                req.setCurCode(createdRequest.getTransactionDetails().getTnxCurCode());
            }
        }

        // TODO: If companyName, applicantAbbvName, beneficiaryName must be explicit in XML,
        // you should either:
        //  1. Add them as fields in ExternalTNTRequest
        //  2. Or reuse counterPartyName/customerId if they match business meaning

        return req;
    }
}





++++++++++++++++++++

 
@Service
public class TrackTraceService {

    private static final Logger log = LoggerFactory.getLogger(TrackTraceService.class);

    @Autowired
    private XmlStrategyContext xmlStrategyContext;

    @Autowired
    private TntQueuePublisher tntQueuePublisher;   // already used in FE (or create one)

    public void trigger(ConnexisData data, Element tnxRecord) {
        // Only proceed if mapping is present
        ConnexisAutoISMapping mapping = data.getConnexisAutoISMapping();
        if (mapping == null) {
            return;
        }

        // same conditions you mentioned (customer, step=AutoIS, status=event.status)
        boolean isCustomerOne = data.isCustomerOne();
        boolean stepOk   = "AutoIS".equalsIgnoreCase(mapping.getStep());
        boolean statusOk = Objects.equals(mapping.getStatus(),
                                          tnxRecord.getChildText("STATUS"));

        if (!isCustomerOne || !stepOk || !statusOk) {
            return;
        }

        try {
            // Build request for XML
            ExternalTNTRequest req = ExternalTNTRequest.fromConnexisData(data, tnxRecord);

            // Generate the XML file
            File xmlFile = xmlStrategyContext.generateXml(req, "/tmp");

            // Push to queue (whatever the FE used)
            tntQueuePublisher.publish(xmlFile);

            log.info("Track&Trace XML successfully generated and sent for event {}", data.getEventId());
        } catch (Exception ex) {
            log.error("Track&Trace XML generation failed for {}", data.getEventId(), ex);
        }
    }
}

++++++++++++



@Autowired
private TrackTraceService trackTraceService;

private RequestExtended generateRequestEventModel(ConnexisData connexisData, Element tnxRecord) {
    log.info("Starting to generate Request Event Model for Connexis");

    // ðŸ‘‰ trigger Track & Trace *before* the existing treatment logic
    trackTraceService.trigger(connexisData, tnxRecord);

    RequestExtended request = new RequestExtended();
    if (Objects.equals(connexisData.getTreatmentType(), TREATMENT_TYPE_ATTACHMENT)) {
        request = treatmentTypeAttachment(connexisData, tnxRecord);
    } else if (Objects.equals(connexisData.getTreatmentType(), TREATMENT_TYPE_EVENT)) {
        request = treatmentTypeEvent(connexisData, tnxRecord);
    } else if (connexisData.getTreatmentType() == null) {
        request = processor.createRequest(tnxRecord, connexisData);
        connexisData.setProcessedAs(CommonConstants.TREATMENT_TYPE_REQUEST);
        log.info("Request Event Model Generated, will be treated as: '{}'.",
                 connexisData.getProcessedAs());
    }
    return request;
}





-----------------------------


handleCourierEvent(event: any) {
  if (event.action === 'SAVE') {
    // Ensure sideNavDetails and courierDetails exist
    if (!this.instructionSheet.sideNavDetails) {
      this.instructionSheet.sideNavDetails = {};
    }

    if (!Array.isArray(this.instructionSheet.sideNavDetails['courierDetails'])) {
      this.instructionSheet.sideNavDetails['courierDetails'] = [];
    }

    // Add the new saved courier (you can push only needed data if event contains more)
    this.instructionSheet.sideNavDetails['courierDetails'].push({ ...event });

    // Optional: trigger change detection if UI doesn't update automatically
    this.cdRef.detectChanges();
  }
}






!!!!!!!!!!!!!!!++++


import { ComponentFixture, TestBed } from '@angular/core/testing';
import { ReactiveFormsModule, FormBuilder } from '@angular/forms';
import { HttpClientTestingModule } from '@angular/common/http/testing';
import { StoreModule } from '@ngrx/store';

import { CreateCourierComponent } from './create-courier.component';
import { InitiatEventDataService } from 'app/initiate-event/shared/initiate-event-data.service';
import { SliderService } from 'app/initiate-event/services/slider.service';
import { HTTPStatus } from 'app/services/loading-indicator';

describe('CreateCourierComponent', () => {
  let component: CreateCourierComponent;
  let fixture: ComponentFixture<CreateCourierComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [CreateCourierComponent],
      imports: [
        ReactiveFormsModule,
        HttpClientTestingModule,
        StoreModule.forRoot({})
      ],
      providers: [
        FormBuilder,
        InitiatEventDataService,
        SliderService,
        HTTPStatus
      ],
      teardown: { destroyAfterEach: false }
    }).compileComponents();
  });

  beforeEach(() => {
    fixture = TestBed.createComponent(CreateCourierComponent);
    component = fixture.componentInstance;

    // Initialize required input values before running tests
    component.eventId = 'EVT123';
    component.uid = 'USR001';
    component.instructionSheet = {
      stepName: 'Initiate',
      sideNavDetails: {}
    } as any;

    fixture.detectChanges();
  });

  it('should create the CreateCourierComponent', () => {
    expect(component).toBeTruthy();
  });

  it('should build the form with default values', () => {
    expect(component.form).toBeTruthy();
    expect(component.form.get('courierPartnerWaybillNo')).toBeTruthy();
    expect(component.form.valid).toBeFalsy(); // initially invalid
  });

  // Add more tests for form submission, successful API calls, etc.
});





------------

@Test
public void testCreateCourier() {
    Courier courier = new Courier();
    courier.setEventId("1");
    courier.setCourierPartnerCategory("DHL");
    courier.setCourierPartnerWaybillNo("WB123");
    
    CourierEntity courierEntity = DpwRepositoryTestHelper.createCourier();

    // Fix this for void return method
    willDoNothing().given(dpwEventHelper).checkLockForAllApis(any(), any(), any());

    // Mock repository calls
    given(eventRepository.findById("1")).willReturn(Optional.of(DpwRepositoryTestHelper.createEventEntity()));
    given(courierRepository.save(any(CourierEntity.class))).willReturn(courierEntity);
    given(dpwSideNavCountRepository.findByEventId("1")).willReturn(new SideNavCountEntity());

    Courier result = courierService.createCourier("bnppuid", courier, "Initiate");

    assertNotNull(result);
    assertEquals("1", result.getEventId());
}








+------------

@Test
public void testUpdateCourier() {
    // Arrange
    CourierEntity courierEntity = DpwRepositoryTestHelper.createCourier(); // Returns CourierEntity with Long id and String eventId
    Courier courier = DpwDTOConverter.convert(courierEntity, Courier.class); // Converts to model object

    // Mock getReferenceById (expects Long)
    given(courierRepository.getReferenceById(courier.getId())).willReturn(courierEntity);

    // Mock save
    given(courierRepository.save(any(CourierEntity.class))).willReturn(courierEntity);

    // Mock side nav count repository (expects Long eventId â€” convert from String)
    given(dpwSideNavCountRepository.findByEventId(Long.valueOf(courier.getEventId())))
        .willReturn(DpwRepositoryTestHelper.createDpwSideNavCount());

    // Act
    Courier result = courierService.updateCourier(
        "bnppuid",
        String.valueOf(courier.getId()), // id as String
        courier,
        "Initiate"
    );

    // Assert
    assertNotNull(result);
    assertEquals(courier.getId(), result.getId());
    assertEquals(courier.getEventId(), result.getEventId());
}



------------------------
@Service
public class CourierServiceImpl extends
        AbstractAdminServiceImpl<CourierEntity, Courier, CourierRepository, CourierRepositoryCustom> 
        implements CourierService {

    @Autowired
    private CourierRepository courierRepository;

    @Autowired
    private EventRepository eventRepository;

    @Autowired
    private DpwEventHelper dpwEventHelper;

    @Autowired
    private DpwSideNavCountRepository dpwSideNavCountRepository;

    @Autowired
    private ReferentialUtil referentialUtil;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Courier createCourier(String bnppuid, Courier courier, String stepName) {
        validateEventId(courier.getEventId());

        if (stepName != null) {
            dpwEventHelper.checkLockForAllApis(stepName, bnppuid, courier.getEventId());
        }

        // Create Courier Entity
        CourierEntity entity = new CourierEntity();
        entity.setEventId(courier.getEventId());
        entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
        entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());

        // Set the username from ReferentialUtil
        String resolvedCreatedBy = referentialUtil.getUserNameInString(bnppuid, true);
        entity.setCreatedBy(resolvedCreatedBy);
        entity.setCreatedOn(LocalDateTime.now(ZoneOffset.UTC));

        CourierEntity saved = courierRepository.save(entity);

        // Update the count for Courier
        updateCourierCount(courier.getEventId(), 1);  // Increment count by 1 when a courier is created

        return mapEntityToModel(saved);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Courier updateCourier(String bnppuid, String courierId, Courier courier, String stepName) {
        long id;
        try {
            id = Long.parseLong(courierId);
        } catch (NumberFormatException ex) {
            throw new DpwEntityNotFoundException("Invalid courier ID format: " + courierId);
        }

        validateEventId(courier.getEventId());

        Optional<CourierEntity> optional = courierRepository.findById(id);
        if (optional.isEmpty()) {
            throw new DpwEntityNotFoundException("Courier entry not found for id: " + courierId);
        }

        if (stepName != null) {
            dpwEventHelper.checkLockForAllApis(stepName, bnppuid, courier.getEventId());
        }

        CourierEntity entity = optional.get();
        entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
        entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());

        // Set the updated username from ReferentialUtil
        String resolvedUpdatedBy = referentialUtil.getUserNameInString(bnppuid, true);
        entity.setUpdatedBy(resolvedUpdatedBy);
        entity.setUpdatedOn(LocalDateTime.now(ZoneOffset.UTC));

        CourierEntity saved = courierRepository.save(entity);

        return mapEntityToModel(saved);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Map<String, String> deleteCourier(String courierId, String bnppuid, String stepName) {
        Long id;

        try {
            id = Long.parseLong(courierId);
        } catch (NumberFormatException ex) {
            throw new DpwEntityNotFoundException("Invalid courier ID format: " + courierId);
        }

        Optional<CourierEntity> optional = courierRepository.findById(id);
        if (optional.isEmpty()) {
            throw new DpwEntityNotFoundException("Courier entry not found for id: " + courierId);
        }

        CourierEntity entity = optional.get();

        if (stepName != null) {
            dpwEventHelper.checkLockForAllApis(stepName, bnppuid, entity.getEventId());
        }

        courierRepository.deleteById(id);

        // Update the count for Courier (decrement count by 1)
        updateCourierCount(entity.getEventId(), -1);

        Map<String, String> response = new HashMap<>();
        response.put("message", "Courier deleted successfully");

        return response;
    }

    @Override
    public List<Courier> getCourierListByEventId(String eventId, String bnppuid) {
        List<CourierEntity> list = courierRepository.findByEventId(eventId);

        // Fetching the SideNav count details
        SideNavCountEntity dpwSideNavEntity = dpwSideNavCountRepository.findByEventId(eventId);

        Long courierCount = 0L;
        if (dpwSideNavEntity != null) {
            courierCount = dpwSideNavEntity.getCourierTotalCount();  // Get the total count
        }

        // Map the entities to models and set the count
        List<Courier> couriers = list.stream().map(entity -> {
            Courier courier = mapEntityToModel(entity);
            courier.setCourierCount(courierCount.toString());  // Add the count to each courier
            return courier;
        }).collect(Collectors.toList());

        return couriers;
    }

    private void updateCourierCount(String eventId, int increment) {
        SideNavCountEntity dpwSideNavEntity = dpwSideNavCountRepository.findByEventId(eventId);

        if (dpwSideNavEntity == null) {
            dpwSideNavEntity = new SideNavCountEntity();
            dpwSideNavEntity.setEventId(eventId);
            dpwSideNavEntity.setCourierTotalCount(0L);
            dpwSideNavEntity.setCourierActiveCount(0L);
        }

        // Update the counts
        Long totalCount = dpwSideNavEntity.getCourierTotalCount() + increment;
        dpwSideNavEntity.setCourierTotalCount(totalCount);
        dpwSideNavEntity.setCourierActiveCount(dpwSideNavEntity.getCourierActiveCount() + increment); // Increment active count

        dpwSideNavCountRepository.save(dpwSideNavEntity);
    }

    private void validateEventId(String eventId) {
        if (!eventRepository.findById(eventId).isPresent()) {
            throw new DpwEntityNotFoundException("Invalid eventId: " + eventId);
        }
    }
}



----------




@Slf4j
@RequiredArgsConstructor
@Service
public class CourierServiceImpl implements CourierService {

    private final CourierRepository courierRepository;
    private final ReferentialUtil referentialUtil;
    private final DpwSideNavCountRepository dpwSideNavCountRepository;

    @Transactional
    @Override
    public Courier createCourier(String bnppuid, Courier courier, String stepName) {
        CourierEntity entity = mapModelToEntity(courier);
        entity.setCreatedBy(bnppuid);
        entity.setCreatedOn(LocalDateTime.now(ZoneOffset.UTC));
        entity.setCreatedByUser(referentialUtil.getUserNameInString(bnppuid, true));
        entity.setUpdatedBy(bnppuid);
        entity.setUpdatedOn(LocalDateTime.now(ZoneOffset.UTC));
        entity.setLastModifiedBy(referentialUtil.getUserNameInString(bnppuid, true));
        entity.setLastModifiedOn(LocalDateTime.now(ZoneOffset.UTC));

        Courier saved = mapEntityToModel(courierRepository.save(entity));
        updateCourierCount(saved.getEventId(), true);

        return saved;
    }

    @Transactional
    @Override
    public Courier updateCourier(String bnppuid, Courier courier, String stepName) {
        CourierEntity existing = courierRepository.findById(courier.getId())
            .orElseThrow(() -> new DpwEntityNotFoundException("Courier not found", courier.getId().toString()));

        courier.setCreatedBy(existing.getCreatedBy());
        courier.setCreatedByUser(existing.getCreatedByUser());
        courier.setCreatedOn(existing.getCreatedOn());

        CourierEntity updatedEntity = mapModelToEntity(courier);
        updatedEntity.setUpdatedBy(bnppuid);
        updatedEntity.setUpdatedOn(LocalDateTime.now(ZoneOffset.UTC));
        updatedEntity.setLastModifiedBy(referentialUtil.getUserNameInString(bnppuid, true));
        updatedEntity.setLastModifiedOn(LocalDateTime.now(ZoneOffset.UTC));

        return mapEntityToModel(courierRepository.save(updatedEntity));
    }

    @Transactional
    @Override
    public boolean deleteCourier(String courierId, String eventId, String stepName) {
        Long id = Long.parseLong(courierId);
        CourierEntity entity = courierRepository.findById(id)
            .orElseThrow(() -> new DpwEntityNotFoundException("Courier not found", courierId));

        courierRepository.delete(entity);
        updateCourierCount(eventId, false);

        return true;
    }

    private void updateCourierCount(String eventId, boolean isCreate) {
        SideNavCountEntity countEntity = dpwSideNavCountRepository.findByEventId(eventId);
        if (countEntity == null) {
            countEntity = new SideNavCountEntity();
            countEntity.setEventId(eventId);
            countEntity.setCourierTotalCount(0L);
            countEntity.setCourierActiveCount(0L);
        }

        Long total = countEntity.getCourierTotalCount() != null ? countEntity.getCourierTotalCount() : 0L;
        Long active = countEntity.getCourierActiveCount() != null ? countEntity.getCourierActiveCount() : 0L;

        if (isCreate) {
            countEntity.setCourierTotalCount(total + 1);
            countEntity.setCourierActiveCount(active + 1);
        } else {
            countEntity.setCourierTotalCount(Math.max(0, total - 1));
            countEntity.setCourierActiveCount(Math.max(0, active - 1));
        }

        dpwSideNavCountRepository.save(countEntity);
    }

    private CourierEntity mapModelToEntity(Courier courier) {
        // map model to entity (manual or mapstruct-based)
    }

    private Courier mapEntityToModel(CourierEntity entity) {
        // map entity to model (manual or mapstruct-based)
    }
}



----------------

.courier-list {
  padding: 0.5rem;
  
  .courier-card {
    background: #d1ede8;
    border: 1px solid #d1ede8;
    border-radius: 5px;
    padding: 1rem;
    margin-bottom: 0.75rem;
    font-family: $font-family-BNPPSansBold;

    .row {
      margin: 0;
    }

    .col, .col-auto, .col.text-end {
      padding: 0.25rem 0;
    }

    hr {
      border-top: 1px solid #bbb;
      margin: 0.75rem 0;
    }

    .btn-sm {
      font-size: 0.85rem;
    }

    .btn-outline-secondary {
      color: #504d4d;
      border-color: #504d4d;

      &:hover {
        color: #0d0d13;
        border-color: #0d0d13;
      }

      i {
        margin-right: 0.25rem;
      }
    }

    .btn-danger {
      background-color: #e74c3c;
      border: none;

      i {
        color: white;
      }
    }

    .courier-footer {
      font-size: 0.9rem;
      color: #0e5549;

      div {
        margin-bottom: 0.2rem;

        i {
          margin-right: 0.3rem;
          color: #0d0d13;
        }

        .fa-calendar {
          margin-left: 1rem;
        }
      }
    }
  }
}


--------------

<div class="courier-list" *ngFor="let courier of couriers$ | async">
  <div class="courier-card">
    
    <!-- Top section -->
    <div class="row align-items-start justify-content-between">
      <!-- Left: Courier Partner & Waybill -->
      <div class="col">
        <div><strong>Courier Partner:</strong> {{ courier.courierPartnerCategory }}</div>
        <div><strong>Waybill No:</strong> {{ courier.courierPartnerWaybillNo }}</div>
      </div>

      <!-- Right: Delete button -->
      <div class="col-auto">
        <button 
          class="btn btn-danger btn-sm"
          [disabled]="isDisabled"
          (click)="deleteCourier.emit(courier)">
          <i class="pi pi-trash"></i>
        </button>
      </div>
    </div>

    <hr class="my-2" />

    <!-- Bottom section -->
    <div class="row align-items-end justify-content-between mt-2">
      <!-- Bottom-left: Modify Button -->
      <div class="col-auto">
        <button 
          class="btn btn-outline-secondary btn-sm"
          [disabled]="isDisabled"
          (click)="onEdit.emit(courier)">
          <i class="pi pi-pencil me-1"></i> Modify
        </button>
      </div>

      <!-- Bottom-right: Created/Updated Info -->
      <div class="col text-end courier-footer">
        <div>
          <i class="fa fa-user"></i> Created by: {{ courier.createdByUser }}
          <i class="fa fa-calendar ms-2"></i> {{ formatDate(courier.createdOn) }}
        </div>
        <div>
          <i class="fa fa-user"></i> Updated by: {{ courier.lastModifiedBy || courier.updatedBy }}
          <i class="fa fa-calendar ms-2"></i> {{ formatDate(courier.lastModifiedOn || courier.updatedOn) }}
        </div>
      </div>
    </div>
    
  </div>
</div>





-------
.courier-list {
  .courier-card {
    background-color: #f0fdfc;
    border: 1px solid #cce3e1;
    border-radius: 8px;
    padding: 1rem 1.2rem;
    margin-bottom: 1rem;
    font-family: 'Segoe UI', sans-serif;
    font-size: 14px;

    .row {
      margin: 0;
    }

    .col,
    .col-auto {
      padding: 0.25rem 0.5rem;
    }

    .btn {
      font-size: 13px;
      padding: 0.3rem 0.6rem;
    }

    .btn-outline-secondary {
      border-color: #6c757d;
      color: #6c757d;
    }

    .btn-outline-secondary:hover {
      background-color: #6c757d;
      color: white;
    }

    .btn-danger {
      background-color: #dc3545;
      border: none;
    }

    .btn-danger i {
      font-size: 14px;
    }

    .courier-footer {
      font-size: 13px;
      color: #333;

      i.fa {
        margin-right: 4px;
        color: #444;
      }

      .fa-calendar {
        margin-left: 10px;
        color: #888;
      }

      div {
        margin-bottom: 4px;
      }
    }

    hr {
      border-color: #d0e0df;
      margin: 0.5rem 0;
    }
  }
}


------------------


import { Component, OnInit, Input, Output, EventEmitter, OnDestroy } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { Courier } from '@api/controller';
import { InitiatEventDataService } from 'app/initiate-event/shared/initiate-event-data.service';
import { formatDate, getSessionStorageValue } from '@shared/utils';
import { SliderService } from 'app/initiate-event/services/slider.service';
import { Store, select } from '@ngrx/store';
import { getUserJurisdiction } from 'app/initiate-event/store/selectors/juridiction.selector';
import { UserJurisdiction } from '@api/referential';
import { AppState } from 'app/store/state/app.state';

@Component({
  selector: 'dpw-courier-list',
  templateUrl: './courier-list.component.html',
  styleUrls: ['./courier-list.component.scss']
})
export class CourierListComponent implements OnInit, OnDestroy {
  @Input('eventId') eventId: string = null;
  @Input('courierId') courierId: string = null;
  @Input('instructionSheet') instructionSheet: any;
  @Input('isCourierManagementPermission') isCourierManagementPermission: boolean = false;

  @Output() onModifyCourier: EventEmitter<Courier> = new EventEmitter();
  @Output() onDeleteCourier: EventEmitter<Courier> = new EventEmitter();

  couriers$ = new BehaviorSubject<Courier[]>([]);
  listeners: any;
  uid: string;

  constructor(
    private initiateEventDataService: InitiatEventDataService,
    private sliderService: SliderService,
    private readonly store: Store<AppState>
  ) {
    this.listeners = this.sliderService.onLoadData().addListener('Courier', () => {
      this.getCouriers();
    });
  }

  ngOnInit(): void {
    this.store.pipe(select(getUserJurisdiction)).subscribe((userInfo: UserJurisdiction) => {
      this.uid = userInfo?.userId;
    });

    this.getCouriers();
  }

  getCouriers(): void {
    this.initiateEventDataService.getCourierList(this.eventId).subscribe((couriers: Courier[]) => {
      this.couriers$.next(couriers);
      this.sliderService.dataLoaded = true;
    });
  }

  updateCourier(courier: Courier): void {
    const fullName = getSessionStorageValue('firstName') || getSessionStorageValue('lastName')
      ? `${getSessionStorageValue('firstName')} ${getSessionStorageValue('lastName')}`
      : null;

    const updatedCourier: Courier = {
      ...courier,
      updatedBy: this.uid,
      updatedByUser: fullName,
      updatedOn: new Date()
    };

    this.initiateEventDataService.updateCourier(updatedCourier, this.instructionSheet?.stepName)
      .subscribe(result => {
        const updatedList = this.couriers$.getValue().map(c =>
          c.id === result.id ? result : c
        );
        this.couriers$.next(updatedList);
      });
  }

  deleteCourier(courier: Courier): void {
    this.initiateEventDataService.deleteCourier(courier.id, this.instructionSheet?.stepName)
      .subscribe(() => {
        const filteredList = this.couriers$.getValue().filter(c => c.id !== courier.id);
        this.couriers$.next(filteredList);
        this.onDeleteCourier.emit(courier);
      });
  }

  formatDate(date: any, format: string = 'DD/MM/yyyy'): string {
    return formatDate(date, format);
  }

  ngOnDestroy(): void {
    this.listeners.removeAllListeners();
  }

  isEditable(): boolean {
    return this.isCourierManagementPermission;
  }

  isDisabled(): boolean {
    return !this.isCourierManagementPermission;
  }
}







-------------------


import { Component, OnInit, Input, Output, EventEmitter, OnDestroy } from '@angular/core';
import { BehaviorSubject, Subscription } from 'rxjs';
import { InitiatEventDataService } from 'app/initiate-event/shared/initiate-event-data.service';
import { Courier } from '@api/controller';
import { formatDate, getSessionStorageValue } from '@shared/utils';
import { SliderService } from 'app/initiate-event/services/slider.service';

@Component({
  selector: 'dpw-courier-list',
  templateUrl: './courier-list.component.html',
  styleUrls: ['./courier-list.component.scss']
})
export class CourierListComponent implements OnInit, OnDestroy {

  @Input() eventId: string | null = null;
  @Input() showModify: boolean = false;
  @Input() showDelete: boolean = false;
  @Input() isDisabled: boolean = false;
  @Input() instructionSheet: any;

  @Output() onModifyCourier: EventEmitter<Courier> = new EventEmitter();
  @Output() onDeleteCourier: EventEmitter<Courier> = new EventEmitter();

  couriers$ = new BehaviorSubject<Courier[]>([]);
  private listener: any;
  private uid: string = '';

  constructor(
    private initiateEventDataService: InitiatEventDataService,
    private sliderService: SliderService
  ) {
    this.listener = this.sliderService.onLoadData().addListener('Courier', () => {
      this.getCouriers();
    });
  }

  ngOnInit(): void {
    this.uid = getSessionStorageValue('userId') || '';
    this.getCouriers();
  }

  getCouriers(): void {
    if (!this.eventId) return;

    this.initiateEventDataService.getCourierList(this.eventId).subscribe((couriers: Courier[]) => {
      this.couriers$.next(couriers || []);
      this.sliderService.dataLoaded = true;
    });
  }

  formatDate(date: any, format = 'DD/MM/yyyy'): string {
    return formatDate(date, format);
  }

  ngOnDestroy(): void {
    this.listener?.removeAllListeners?.();
  }
}





--------------

<ul class="courier-list">
  <li *ngFor="let courier of couriers$ | async" class="courier-item">
    
    <!-- Header -->
    <div class="courier-header">
      <div>
        <b>Courier Partner:</b>
        <span>{{ courier.courierPartnerCategory }}</span>
      </div>

      <div class="waybill">
        <b>Waybill No:</b>
        <span>{{ courier.courierPartnerWaybillNo }}</span>
      </div>
    </div>

    <!-- Meta -->
    <div class="meta-details">
      <div>
        <span class="align">Created by:</span>
        <span>
          <i class="fas fa-user"></i> {{ courier.createdBy }}
          &nbsp; <i class="fas fa-calendar"></i> {{ formatDate(courier.createdOn) }}
        </span>
      </div>

      <div *ngIf="courier.updatedOn">
        <span class="align">Updated by:</span>
        <span>
          <i class="fas fa-user"></i> {{ courier.updatedBy }}
          &nbsp; <i class="fas fa-calendar"></i> {{ formatDate(courier.updatedOn) }}
        </span>
      </div>
    </div>

    <!-- Actions -->
    <div class="courier-actions">
      <button
        pButton
        icon="pi pi-pencil"
        class="p-button-sm p-button-text p-button-info"
        (click)="onModifyCourier.emit(courier)"
        [disabled]="isDisabled"
        *ngIf="showModify"
        adminSelenium="courier_modify_btn"
      ></button>

      <button
        pButton
        icon="pi pi-trash"
        class="p-button-sm p-button-text p-button-danger"
        (click)="onDeleteCourier.emit(courier)"
        [disabled]="isDisabled"
        *ngIf="showDelete"
        adminSelenium="courier_delete_btn"
      ></button>
    </div>

  </li>
</ul>





-----------------------



package com.bnpparibas.dpw.controller;

import com.bnpparibas.dpw.api.CourierApi;
import com.bnpparibas.dpw.controller.model.Courier;
import com.bnpparibas.dpw.service.CourierService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequiredArgsConstructor
public class CourierController implements CourierApi {

    private final CourierService courierService;

    @Override
    @PreAuthorize("hasopsPermission(#branchCode, null, 'WriteCourrier')")
    public ResponseEntity<Courier> createCourier(String branchCode, String countryCode, String bnppuid, String stepName, Courier body) {
        Courier courierModel = courierService.createCourier(bnppuid, body, stepName);
        return new ResponseEntity<>(courierModel, HttpStatus.OK);
    }

    @Override
    @PreAuthorize("hasopsPermission(#branchCode, null, 'ReadCourrier')")
    public ResponseEntity<List<Courier>> searchCourierList(String branchCode, String countryCode, String bnppuid, String eventId) {
        List<Courier> courierList = courierService.getCourierListByEventId(eventId, bnppuid);
        return new ResponseEntity<>(courierList, HttpStatus.OK);
    }

    @Override
    @PreAuthorize("hasopsPermission(#branchCode, null, 'UpdateCourrier')")
    public ResponseEntity<Courier> updateCourier(String branchCode, String countryCode, String bnppuid, String courierId, String stepName, Courier body) {
        Courier updated = courierService.updateCourier(bnppuid, courierId, body, stepName);
        return new ResponseEntity<>(updated, HttpStatus.OK);
    }

    @Override
    @PreAuthorize("hasopsPermission(#branchCode, null, 'DeleteCourrier')")
    public ResponseEntity<Void> deleteCourier(String branchCode, String countryCode, String bnppuid, String courierId, String stepName) {
        courierService.deleteCourier(courierId, bnppuid, stepName);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }
}

___________________



@Override
@Transactional(rollbackFor = Exception.class)
public void deleteCourier(String courierId, String bnppuid, String stepName) {
    Long id;
    try {
        id = Long.parseLong(courierId);
    } catch (NumberFormatException ex) {
        throw new DpwEntityNotFoundException("Invalid courier ID format: " + courierId);
    }

    Optional<CourierEntity> optional = courierRepository.findById(id);
    if (optional.isEmpty()) {
        throw new DpwEntityNotFoundException("Courier entry not found for id: " + courierId);
    }

    CourierEntity entity = optional.get();

    if (stepName != null) {
        dpwEventHelper.checkLockForAllApis(stepName, bnppuid, entity.getEventId());
    }

    courierRepository.deleteById(id); // âœ… this now receives a Long
}


__________________________

@Override
@Transactional(rollbackFor = Exception.class)
public Courier updateCourier(String bnppuid, String courierId, Courier courier, String stepName) {
    Long id;
    try {
        id = Long.parseLong(courierId);
    } catch (NumberFormatException ex) {
        throw new DpwEntityNotFoundException("Invalid courier ID format: " + courierId);
    }

    validateEventId(courier.getEventId());

    Optional<CourierEntity> optional = courierRepository.findById(id);
    if (optional.isEmpty()) {
        throw new DpwEntityNotFoundException("Courier entry not found for id: " + courierId);
    }

    if (stepName != null) {
        dpwEventHelper.checkLockForAllApis(stepName, bnppuid, courier.getEventId());
    }

    CourierEntity entity = optional.get();

    entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
    entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());

    String resolvedUpdatedBy = dpwEventHelper.setCreatedOrClosedByField(
            courier.getUpdatedBy(), bnppuid, courier.getUpdatedByUser(), true);

    entity.setUpdatedBy(resolvedUpdatedBy);
    entity.setUpdatedOn(LocalDateTime.now(ZoneOffset.UTC));

    CourierEntity saved = courierRepository.save(entity);
    return mapEntityToModel(saved); // This assumes you have this method in parent class
}




--------
package com.bnpparibas.dpw.service.impl;

import com.bnpparibas.dpw.controller.model.Courier;
import com.bnpparibas.dpw.entity.CourierEntity;
import com.bnpparibas.dpw.entity.EventEntity;
import com.bnpparibas.dpw.exception.DpwEntityNotFoundException;
import com.bnpparibas.dpw.helper.DpwEventHelper;
import com.bnpparibas.dpw.repository.CourierRepository;
import com.bnpparibas.dpw.repository.EventRepository;
import com.bnpparibas.dpw.service.CourierService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class CourierServiceImpl implements CourierService {

    @Autowired
    private CourierRepository courierRepository;

    @Autowired
    private EventRepository eventRepository;

    @Autowired
    private DpwEventHelper dpwEventHelper;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Courier createCourier(String bnppuid, Courier courier, String stepName) {
        validateEventId(courier.getEventId());

        if (stepName != null) {
            dpwEventHelper.checkLockForAllApis(stepName, bnppuid, courier.getEventId());
        }

        CourierEntity entity = new CourierEntity();
        entity.setEventId(courier.getEventId());
        entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
        entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());

        String resolvedCreatedBy = dpwEventHelper.setCreatedOrClosedByField(
                courier.getCreatedBy(), bnppuid, courier.getCreatedByUser(), true
        );
        entity.setCreatedBy(resolvedCreatedBy);
        entity.setCreatedOn(LocalDateTime.now(ZoneOffset.UTC));

        CourierEntity saved = courierRepository.save(entity);
        return mapEntityToModel(saved);
    }

    @Override
    public List<Courier> getCourierListByEventId(String eventId, String bnppuid) {
        List<CourierEntity> list = courierRepository.findByEventId(eventId);
        return list.stream().map(this::mapEntityToModel).collect(Collectors.toList());
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Courier updateCourier(String bnppuid, String courierId, Courier courier, String stepName) {
        Long id = parseId(courierId);
        validateEventId(courier.getEventId());

        Optional<CourierEntity> optional = courierRepository.findById(id);
        if (optional.isEmpty()) {
            throw new DpwEntityNotFoundException("Courier entry not found for id: " + courierId);
        }

        if (stepName != null) {
            dpwEventHelper.checkLockForAllApis(stepName, bnppuid, courier.getEventId());
        }

        CourierEntity entity = optional.get();
        entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
        entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());

        String resolvedUpdatedBy = dpwEventHelper.setCreatedOrClosedByField(
                courier.getUpdatedBy(), bnppuid, courier.getUpdatedByUser(), true
        );
        entity.setUpdatedBy(resolvedUpdatedBy);
        entity.setUpdatedOn(LocalDateTime.now(ZoneOffset.UTC));

        CourierEntity saved = courierRepository.save(entity);
        return mapEntityToModel(saved);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void deleteCourier(String courierId, String bnppuid, String stepName) {
        Long id = parseId(courierId);

        Optional<CourierEntity> optional = courierRepository.findById(id);
        if (optional.isEmpty()) {
            throw new DpwEntityNotFoundException("Courier entry not found for id: " + courierId);
        }

        CourierEntity entity = optional.get();

        if (stepName != null) {
            dpwEventHelper.checkLockForAllApis(stepName, bnppuid, entity.getEventId());
        }

        courierRepository.deleteById(id); // Hard delete
    }

    private Courier mapEntityToModel(CourierEntity entity) {
        Courier model = new Courier();
        model.setId(entity.getId() != null ? entity.getId().toString() : null);
        model.setEventId(entity.getEventId());
        model.setCourierPartnerCategory(entity.getCourierPartnerCategory());
        model.setCourierPartnerWaybillNo(entity.getCourierPartnerWaybillNo());
        model.setCreatedBy(entity.getCreatedBy());
        model.setCreatedOn(entity.getCreatedOn());
        model.setUpdatedBy(entity.getUpdatedBy());
        model.setUpdatedOn(entity.getUpdatedOn());
        return model;
    }

    private void validateEventId(String eventId) {
        if (!eventRepository.existsById(eventId)) {
            throw new DpwEntityNotFoundException("Invalid eventId: " + eventId);
        }
    }

    private Long parseId(String idStr) {
        try {
            return Long.parseLong(idStr);
        } catch (NumberFormatException ex) {
            throw new DpwEntityNotFoundException("Invalid ID format: " + idStr);
        }
    }
}





-----------------------



package com.bnpparibas.dpw.service.impl;

import com.bnpparibas.dpw.entity.CourierEntity;
import com.bnpparibas.dpw.entity.EventEntity;
import com.bnpparibas.dpw.exception.DpwEntityNotFoundException;
import com.bnpparibas.dpw.helper.DpwEventHelper;
import com.bnpparibas.dpw.model.Courier;
import com.bnpparibas.dpw.repository.CourierRepository;
import com.bnpparibas.dpw.repository.EventRepository;
import com.bnpparibas.dpw.service.CourierService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class CourierServiceImpl implements CourierService {

    @Autowired
    private CourierRepository courierRepository;

    @Autowired
    private EventRepository eventRepository;

    @Autowired
    private DpwEventHelper dpwEventHelper;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Courier createCourier(String bnppuid, Courier courier, String stepName) {
        validateEventId(courier.getEventId());

        if (stepName != null) {
            dpwEventHelper.checkLockForAllApis(stepName, bnppuid, courier.getEventId());
        }

        CourierEntity entity = new CourierEntity();
        entity.setEventId(courier.getEventId());
        entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
        entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());

        String resolvedCreatedBy = dpwEventHelper.setCreatedOrClosedByField(
                courier.getCreatedBy(), bnppuid, courier.getCreatedByUser(), true
        );
        entity.setCreatedBy(resolvedCreatedBy);
        entity.setCreatedOn(LocalDateTime.now(ZoneOffset.UTC));

        CourierEntity saved = courierRepository.save(entity);
        return mapEntityToModel(saved);
    }

    @Override
    public List<Courier> getCourierListByEventId(String eventId, String bnppuid) {
        List<CourierEntity> list = courierRepository.findByEventId(eventId);
        return list.stream().map(this::mapEntityToModel).collect(Collectors.toList());
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Courier updateCourier(String bnppuid, Long id, Courier courier, String stepName) {
        validateEventId(courier.getEventId());

        Optional<CourierEntity> optional = courierRepository.findById(id);
        if (optional.isEmpty()) {
            throw new DpwEntityNotFoundException("Courier entry not found for id: " + id);
        }

        if (stepName != null) {
            dpwEventHelper.checkLockForAllApis(stepName, bnppuid, courier.getEventId());
        }

        CourierEntity entity = optional.get();
        entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
        entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());

        String resolvedUpdatedBy = dpwEventHelper.setCreatedOrClosedByField(
                courier.getUpdatedBy(), bnppuid, courier.getUpdatedByUser(), true
        );
        entity.setUpdatedBy(resolvedUpdatedBy);
        entity.setUpdatedOn(LocalDateTime.now(ZoneOffset.UTC));

        CourierEntity saved = courierRepository.save(entity);
        return mapEntityToModel(saved);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void deleteCourier(Long id, String bnppuid) {
        if (!courierRepository.existsById(id)) {
            throw new DpwEntityNotFoundException("Courier entry not found for id: " + id);
        }
        courierRepository.deleteById(id); // Hard delete
    }

    private Courier mapEntityToModel(CourierEntity entity) {
        Courier model = new Courier();
        model.setId(entity.getId());
        model.setEventId(entity.getEventId());
        model.setCourierPartnerCategory(entity.getCourierPartnerCategory());
        model.setCourierPartnerWaybillNo(entity.getCourierPartnerWaybillNo());
        model.setCreatedBy(entity.getCreatedBy());
        model.setCreatedOn(entity.getCreatedOn());
        model.setUpdatedBy(entity.getUpdatedBy());
        model.setUpdatedOn(entity.getUpdatedOn());
        return model;
    }

    private void validateEventId(String eventId) {
        if (!eventRepository.existsById(eventId)) {
            throw new DpwEntityNotFoundException("Invalid eventId: " + eventId);
        }
    }
}



------------------66666----------
package com.bnpparibas.dpw.service.impl;

import com.bnpparibas.dpw.entity.CourierEntity;
import com.bnpparibas.dpw.entity.EventEntity;
import com.bnpparibas.dpw.exception.DpwEntityNotFoundException;
import com.bnpparibas.dpw.model.Courier;
import com.bnpparibas.dpw.repository.CourierRepository;
import com.bnpparibas.dpw.repository.EventRepository;
import com.bnpparibas.dpw.service.CourierService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class CourierServiceImpl implements CourierService {

    @Autowired
    private CourierRepository courierRepository;

    @Autowired
    private EventRepository eventRepository;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Courier createCourier(String bnppuid, Courier courier) {
        validateEventId(courier.getEventId());

        CourierEntity entity = new CourierEntity();
        entity.setEventId(courier.getEventId());
        entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
        entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());
        entity.setCreatedBy(bnppuid);
        entity.setCreatedOn(LocalDateTime.now(ZoneOffset.UTC));

        CourierEntity saved = courierRepository.save(entity);
        return mapEntityToModel(saved);
    }

    @Override
    public List<Courier> getCourierListByEventId(String eventId, String bnppuid) {
        List<CourierEntity> list = courierRepository.findByEventId(eventId);
        return list.stream().map(this::mapEntityToModel).collect(Collectors.toList());
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Courier updateCourier(String bnppuid, Long id, Courier courier) {
        validateEventId(courier.getEventId());

        Optional<CourierEntity> optional = courierRepository.findById(id);
        if (optional.isEmpty()) {
            throw new DpwEntityNotFoundException("Courier entry not found for id: " + id);
        }

        CourierEntity entity = optional.get();
        entity.setCourierPartnerCategory(courier.getCourierPartnerCategory());
        entity.setCourierPartnerWaybillNo(courier.getCourierPartnerWaybillNo());
        entity.setUpdatedBy(bnppuid);
        entity.setUpdatedOn(LocalDateTime.now(ZoneOffset.UTC));

        CourierEntity saved = courierRepository.save(entity);
        return mapEntityToModel(saved);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void deleteCourier(Long id, String bnppuid) {
        if (!courierRepository.existsById(id)) {
            throw new DpwEntityNotFoundException("Courier entry not found for id: " + id);
        }
        courierRepository.deleteById(id); // hard delete
    }

    private Courier mapEntityToModel(CourierEntity entity) {
        Courier model = new Courier();
        model.setId(entity.getId());
        model.setEventId(entity.getEventId());
        model.setCourierPartnerCategory(entity.getCourierPartnerCategory());
        model.setCourierPartnerWaybillNo(entity.getCourierPartnerWaybillNo());
        model.setCreatedBy(entity.getCreatedBy());
        model.setCreatedOn(entity.getCreatedOn());
        model.setUpdatedBy(entity.getUpdatedBy());
        model.setUpdatedOn(entity.getUpdatedOn());
        return model;
    }

    private void validateEventId(String eventId) {
        if (!eventRepository.existsById(eventId)) {
            throw new DpwEntityNotFoundException("Invalid eventId: " + eventId);
        }
    }
}




--------------------------------------------
@WebMvcTest(StaticDataController.class)
class StaticDataControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private ExtTrackAndTraceMappingService extTrackAndTraceMappingService;

    @Autowired
    private ObjectMapper mapper;

    @Test
    void testGetExternalTraceAndTrackMapping_shouldReturnList() throws Exception {
        ExternalTrackAndTraceMapping mapping = new ExternalTrackAndTraceMapping();
        List<ExternalTrackAndTraceMapping> mappings = List.of(mapping);

        when(extTrackAndTraceMappingService.getMapping("branchCode==30004;countryCode==FR")).thenReturn(mapping);

        mockMvc.perform(get("/v1/admin/ext-trackandtraceMapping")
                        .header("bnppuid", "h59900")
                        .param("query", "branchCode==30004;countryCode==FR"))
                .andExpect(status().isOk())
                .andExpect(content().json(mapper.writeValueAsString(mappings)));
    }

    @Test
    void testGetExternalTraceAndTrackMapping_shouldReturnEmptyListWhenNull() throws Exception {
        when(extTrackAndTraceMappingService.getMapping("branchCode==999")).thenReturn(null);

        mockMvc.perform(get("/v1/admin/ext-trackandtraceMapping")
                        .header("bnppuid", "h59900")
                        .param("query", "branchCode==999"))
                .andExpect(status().isOk())
                .andExpect(content().json("[]"));
    }
}


________



@ExtendWith(MockitoExtension.class)
class ExtTrackAndTraceMappingServiceImplTest {

    @Mock
    private ExtTrackAndTraceMappingRepository repository;

    @Mock
    private CommonMapper mapper;

    @Mock
    private ScoreCalculator calculator;

    @InjectMocks
    private ExtTrackAndTraceMappingServiceImpl service;

    @Test
    void testGetMapping_withValidQuery_shouldReturnTopPriorityMapping() {
        String query = "branchCode==30004;countryCode==FR;pgpeCode==ILCI;action==Validated;statusCst==Active";
        ExtTrackAndTraceMappingEntity entity = new ExtTrackAndTraceMappingEntity();
        List<ExtTrackAndTraceMappingEntity> entityList = List.of(entity);

        ExternalTrackAndTraceMapping mapped = new ExternalTrackAndTraceMapping();
        List<ExternalTrackAndTraceMapping> mappedList = List.of(mapped);

        when(repository.findAll(any(Specification.class))).thenReturn(entityList);
        when(mapper.getExtTrackAndTraceMappingModel(entityList)).thenReturn(mappedList);

        ExternalTrackAndTraceMapping result = service.getMapping(query);

        assertNotNull(result);
        assertEquals(mapped, result);
    }

    @Test
    void testGetMapping_withEmptyResult_shouldReturnNull() {
        when(repository.findAll(any(Specification.class))).thenReturn(Collections.emptyList());

        ExternalTrackAndTraceMapping result = service.getMapping("branchCode==999");
        assertNull(result);
    }
}



----------------package com.bnpparibas.dpw.service;

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity;
import com.bnpparibas.dpw.helpers.CustomComparator;
import com.bnpparibas.dpw.helpers.ScoreCalculator;
import com.bnpparibas.dpw.mapper.CommonMapper;
import com.bnpparibas.dpw.referential.model.ExternalTrackAndTraceMapping;
import com.bnpparibas.dpw.repository.ExtTrackAndTraceMappingRepository;
import com.bnpparibas.dpw.rsql.ParseUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;

@Slf4j
@Service
@RequiredArgsConstructor
public class ExtTrackAndTraceMappingServiceImpl implements ExtTrackAndTraceMappingService {

    private final ExtTrackAndTraceMappingRepository extTrackAndTraceMappingRepository;
    private final CommonMapper commonMapper;
    private final ScoreCalculator genericScoreCalculator;

    private static final List<String> fields = List.of(
            "transactionTypeCode",
            "subTransactionTypeCode",
            "productStatusCode",
            "transactionStatusCode"
    );

    @Override
    @Transactional(readOnly = true)
    public List<ExternalTrackAndTraceMapping> getMapping(String query) {
        log.info("[getMapping] RSQL query: {}", query);

        Specification<ExtTrackAndTraceMappingEntity> specification = ParseUtils.parseQuery(
                query,
                new HashMap<>(),
                ExtTrackAndTraceMappingEntity.class
        );

        List<ExtTrackAndTraceMappingEntity> entities = extTrackAndTraceMappingRepository.findAll(specification);

        if (entities.isEmpty()) {
            return Collections.emptyList();
        }

        List<ExternalTrackAndTraceMapping> models = commonMapper.getExtTrackAndTraceMappingModel(entities);

        Map<String, String> paramMap = extractParams(query);
        List<Object> values = fields.stream()
                .map(paramMap::get)
                .toList();

        PriorityQueue<ExternalTrackAndTraceMapping> queue =
                new PriorityQueue<>(new CustomComparator<>(fields, values, genericScoreCalculator));

        queue.addAll(models);

        // return the top result only as a list
        ExternalTrackAndTraceMapping bestMatch = queue.peek();
        return bestMatch != null ? List.of(bestMatch) : Collections.emptyList();
    }

    private Map<String, String> extractParams(String rsql) {
        Map<String, String> map = new HashMap<>();
        if (rsql != null && !rsql.isBlank()) {
            String[] conditions = rsql.split(";");
            for (String condition : conditions) {
                String[] parts = condition.split("==");
                if (parts.length == 2) {
                    map.put(parts[0].trim(), parts[1].trim());
                }
            }
        }
        return map;
    }
}
-------------
package com.bnpparibas.dpw.service.impl;

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity;
import com.bnpparibas.dpw.mapper.CommonMapper;
import com.bnpparibas.dpw.model.ExternalTrackAndTraceMapping;
import com.bnpparibas.dpw.repository.ExtTrackAndTraceMappingRepository;
import com.bnpparibas.dpw.service.ExtTrackAndTraceMappingService;
import com.bnpparibas.dpw.util.ParseUtils;
import com.bnpparibas.dpw.util.PrioritySelector;
import com.bnpparibas.dpw.util.SpecificationUtils;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
public class ExtTrackAndTraceMappingServiceImpl implements ExtTrackAndTraceMappingService {

    @Autowired
    private ExtTrackAndTraceMappingRepository repository;

    @Autowired
    private CommonMapper commonMapper;

    @Autowired
    private SpecificationUtils specificationUtils;

    @Autowired
    private PrioritySelector<ExtTrackAndTraceMappingEntity> prioritySelector;

    private static final List<String> wildcardSupportedFields = Arrays.asList(
            "transactionTypeCode", "subTransactionTypeCode",
            "productStatusCode", "transactionStatusCode"
    );

    @Override
    public List<ExternalTrackAndTraceMapping> getMapping(String query) {
        // Parse the RSQL query to a Map<String, Object>
        Map<String, Object> queryParams = ParseUtils.parseQuery(query, ExtTrackAndTraceMappingEntity.class);

        // Filter out wildcard-supported fields with "*" value
        Map<String, Object> baseParams = new HashMap<>(queryParams);
        wildcardSupportedFields.forEach(field -> {
            if ("*".equals(queryParams.get(field))) {
                baseParams.remove(field);
            }
        });

        // Build specification using mandatory + optional fields excluding wildcards
        Specification<ExtTrackAndTraceMappingEntity> specification =
                specificationUtils.build(baseParams, ExtTrackAndTraceMappingEntity.class);

        // Fetch all records matching the base specification
        List<ExtTrackAndTraceMappingEntity> allMatchedEntities = repository.findAll(specification);

        // Filter for best match using comparator logic and PrioritySelector
        ExtTrackAndTraceMappingEntity bestMatch =
                prioritySelector.getBestMatch(allMatchedEntities, queryParams, wildcardSupportedFields);

        if (bestMatch != null) {
            ExternalTrackAndTraceMapping mapped = commonMapper.convert(bestMatch, ExternalTrackAndTraceMapping.class);
            return List.of(mapped);
        }

        return Collections.emptyList();
    }
}




---------------------

package com.bnpparibas.dpw.service.impl;

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity;
import com.bnpparibas.dpw.mapper.CommonMapper;
import com.bnpparibas.dpw.model.ExternalTrackAndTraceMapping;
import com.bnpparibas.dpw.repository.ExtTrackAndTraceMappingRepository;
import com.bnpparibas.dpw.score.ScoreCalculator;
import com.bnpparibas.dpw.service.ExtTrackAndTraceMappingService;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import java.util.*;

@ExtendWith(MockitoExtension.class)
class ExtTrackAndTraceMappingServiceImplTest {

    @Mock
    private ExtTrackAndTraceMappingRepository repository;

    @Mock
    private CommonMapper commonMapper;

    @Mock
    private ScoreCalculator calculator;

    @InjectMocks
    private ExtTrackAndTraceMappingServiceImpl service;

    @Test
    void getMapping_shouldReturnHighestPriorityMatch() {
        // Sample entity and expected model
        ExtTrackAndTraceMappingEntity entity = new ExtTrackAndTraceMappingEntity();
        entity.setBranchCode("30004");

        ExternalTrackAndTraceMapping model = new ExternalTrackAndTraceMapping();
        model.setBranchCode("30004");

        List<ExtTrackAndTraceMappingEntity> entityList = List.of(entity);
        List<ExternalTrackAndTraceMapping> modelList = List.of(model);

        // Mocking behavior
        when(repository.findAll(any())).thenReturn(entityList);
        when(commonMapper.getExtTrackAndTraceMappingModel(entityList)).thenReturn(modelList);
        when(calculator.calculate(any(), any())).thenReturn(1); // all same score

        // Method call
        ExternalTrackAndTraceMapping result = service.getMapping(
                "30004", "FR", "ILCI", "Validated", "Active",
                null, null, "*", "*", "*", "*"
        );

        assertNotNull(result);
        assertEquals("30004", result.getBranchCode());
        verify(repository).findAll(any());
        verify(commonMapper).getExtTrackAndTraceMappingModel(entityList);
    }

    @Test
    void getMapping_shouldReturnNullIfNoData() {
        when(repository.findAll(any())).thenReturn(Collections.emptyList());

        ExternalTrackAndTraceMapping result = service.getMapping(
                "30004", "FR", "ILCI", "Validated", "Active",
                null, null, "*", "*", "*", "*"
        );

        assertNull(result);
    }
}



----------------------_______________________
package com.bnpparibas.dpw.service.impl;

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity;
import com.bnpparibas.dpw.mapper.CommonMapper;
import com.bnpparibas.dpw.model.ExternalTrackAndTraceMapping;
import com.bnpparibas.dpw.repository.ExtTrackAndTraceMappingRepository;
import com.bnpparibas.dpw.score.ScoreCalculator;
import com.bnpparibas.dpw.service.ExtTrackAndTraceMappingService;
import com.bnpparibas.dpw.util.ParseUtils;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.springframework.data.jpa.domain.Specification;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class ExtTrackAndTraceMappingServiceImplTest {

    @InjectMocks
    private ExtTrackAndTraceMappingServiceImpl service;

    @Mock
    private ExtTrackAndTraceMappingRepository repository;

    @Mock
    private CommonMapper commonMapper;

    @Mock
    private ScoreCalculator scoreCalculator;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testGetMapping_returnsCorrectMapping_whenMatchFound() {
        // Given
        String branchCode = "BR";
        String countryCode = "IN";
        String pgpeCode = "PG";
        String action = "CREATE";
        String statusCst = "ACTIVE";
        String statusCxt = "CTX";
        String prodCode = "PCODE";
        String txnType = "T1";
        String subTxnType = "ST1";
        String prodStatCode = "PSC";
        String txnStatCode = "TSC";

        List<ExtTrackAndTraceMappingEntity> mockEntities = List.of(new ExtTrackAndTraceMappingEntity());
        List<ExternalTrackAndTraceMapping> mockModels = List.of(new ExternalTrackAndTraceMapping().branchCode(branchCode));

        // Mock behavior
        Map<String, Object> queryParams = new HashMap<>();
        queryParams.put("branchCode", branchCode);
        queryParams.put("countryCode", countryCode);
        queryParams.put("pgpeCode", pgpeCode);
        queryParams.put("action", action);
        queryParams.put("statusCst", statusCst);
        queryParams.put("statusCxt", statusCxt);
        queryParams.put("prodCode", prodCode);
        queryParams.put("transactionTypeCode", txnType);
        queryParams.put("subTransactionTypeCode", subTxnType);
        queryParams.put("productStatusCode", prodStatCode);
        queryParams.put("transactionStatusCode", txnStatCode);

        Specification<ExtTrackAndTraceMappingEntity> spec = mock(Specification.class);
        when(ParseUtils.parseQuery(queryParams, ExtTrackAndTraceMappingEntity.class)).thenReturn(spec);
        when(repository.findAll(spec)).thenReturn(mockEntities);
        when(commonMapper.getExtTrackAndTraceMappingModel(mockEntities)).thenReturn(mockModels);

        // When
        ExternalTrackAndTraceMapping result = service.getMapping(
            branchCode, countryCode, pgpeCode, action, statusCst, statusCxt, prodCode, txnType, subTxnType, prodStatCode, txnStatCode
        );

        // Then
        assertNotNull(result);
        assertEquals(branchCode, result.getBranchCode());
    }

    @Test
    void testGetMapping_returnsNull_whenNoResults() {
        String branchCode = "BR";
        String countryCode = "IN";
        String pgpeCode = "PG";
        String action = "CREATE";
        String statusCst = "ACTIVE";

        Map<String, Object> queryParams = Map.of(
            "branchCode", branchCode,
            "countryCode", countryCode,
            "pgpeCode", pgpeCode,
            "action", action,
            "statusCst", statusCst
        );

        Specification<ExtTrackAndTraceMappingEntity> spec = mock(Specification.class);
        when(ParseUtils.parseQuery(queryParams, ExtTrackAndTraceMappingEntity.class)).thenReturn(spec);
        when(repository.findAll(spec)).thenReturn(Collections.emptyList());

        ExternalTrackAndTraceMapping result = service.getMapping(
            branchCode, countryCode, pgpeCode, action, statusCst, null, null, null, null, null, null
        );

        assertNull(result);
    }
}


_____________&___&___________

@Slf4j
@Service
@RequiredArgsConstructor
public class ExtTrackAndTraceMappingServiceImpl implements ExtTrackAndTraceMappingService {

    private final ExtTrackAndTraceMappingRepository extTrackAndTraceMappingRepository;
    private final CommonMapper commonMapper;
    private final ScoreCalculator genericScoreCalculator;

    private static final List<String> fields = List.of(
            "transactionTypeCode", 
            "subTransactionTypeCode", 
            "productStatusCode", 
            "transactionStatusCode"
    );

    @Override
    @Transactional(readOnly = true)
    public ExternalTrackAndTraceMapping getMapping(
            String branchCode,
            String countryCode,
            String pgpeCode,
            String action,
            String statusCst,
            String statusCxt,
            String prodCode,
            String transactionTypeCode,
            String subTransactionTypeCode,
            String productStatusCode,
            String transactionStatusCode) {

        log.info("[getMapping] Input params - branchCode: {}, countryCode: {}, pgpeCode: {}, action: {}, statusCst: {}, statusCxt: {}, prodCode: {}, txnTypeCode: {}, subTxnTypeCode: {}, prodStatusCode: {}, txnStatusCode: {}",
                branchCode, countryCode, pgpeCode, action, statusCst, statusCxt, prodCode, transactionTypeCode, subTransactionTypeCode, productStatusCode, transactionStatusCode);

        // Mandatory RSQL base
        StringBuilder rsql = new StringBuilder();
        rsql.append("branchCode==").append(branchCode).append(";");
        rsql.append("countryCode==").append(countryCode).append(";");
        rsql.append("pgpeCode==").append(pgpeCode).append(";");
        rsql.append("action==").append(action).append(";");
        rsql.append("statusCst==").append(statusCst);

        // Optional fields
        if (statusCxt != null) rsql.append(";statusCxt==").append(statusCxt);
        if (prodCode != null) rsql.append(";prodCode==").append(prodCode);

        // Wildcard-matching fields
        if (transactionTypeCode != null) rsql.append(";transactionTypeCode==").append(transactionTypeCode);
        if (subTransactionTypeCode != null) rsql.append(";subTransactionTypeCode==").append(subTransactionTypeCode);
        if (productStatusCode != null) rsql.append(";productStatusCode==").append(productStatusCode);
        if (transactionStatusCode != null) rsql.append(";transactionStatusCode==").append(transactionStatusCode);

        // Parse RSQL query
        Specification<ExtTrackAndTraceMappingEntity> specification = ParseUtils.parseQuery(
                rsql.toString(), 
                new HashMap<>(), 
                ExtTrackAndTraceMappingEntity.class
        );

        List<ExtTrackAndTraceMappingEntity> entities = extTrackAndTraceMappingRepository.findAll(specification);

        if (!entities.isEmpty()) {
            List<Object> values = Arrays.asList(transactionTypeCode, subTransactionTypeCode, productStatusCode, transactionStatusCode);

            PriorityQueue<ExternalTrackAndTraceMapping> queue =
                    new PriorityQueue<>(new CustomComparator<>(fields, values, genericScoreCalculator));

            queue.addAll(commonMapper.getExtTrackAndTraceMappingModel(entities));
            return queue.peek();
        }

        return null;
    }
}
------++++------------------++





package com.bnpparibas.dpw.service.impl;

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity;
import com.bnpparibas.dpw.mapper.CommonMapper;
import com.bnpparibas.dpw.model.ExternalTrackAndTraceMapping;
import com.bnpparibas.dpw.repository.ExtTrackAndTraceMappingRepository;
import com.bnpparibas.dpw.service.ExtTrackAndTraceMappingService;
import com.bnpparibas.dpw.util.CustomComparator;
import com.bnpparibas.dpw.util.ParseUtils;
import com.bnpparibas.dpw.util.ScoreCalculator;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;

import java.util.*;

@Slf4j
@Service
public class ExtTrackAndTraceMappingServiceImpl implements ExtTrackAndTraceMappingService {

    private final ExtTrackAndTraceMappingRepository extTrackAndTraceMappingRepository;
    private final CommonMapper commonMapper;
    private final ScoreCalculator genericScoreCalculator;

    private static final List<String> fields = List.of(
            "transactionTypeCode", "subTransactionTypeCode", "productStatusCode", "transactionStatusCode"
    );

    public ExtTrackAndTraceMappingServiceImpl(
            ExtTrackAndTraceMappingRepository extTrackAndTraceMappingRepository,
            CommonMapper commonMapper,
            ScoreCalculator genericScoreCalculator) {
        this.extTrackAndTraceMappingRepository = extTrackAndTraceMappingRepository;
        this.commonMapper = commonMapper;
        this.genericScoreCalculator = genericScoreCalculator;
    }

    @Override
    @Transactional
    public ExternalTrackAndTraceMapping getMapping(
            String branchCode,
            String countryCode,
            String pgpeCode,
            String action,
            String statusCst,
            String statusCxt,
            String prodCode,
            String transactionTypeCode,
            String subTransactionTypeCode,
            String productStatusCode,
            String transactionStatusCode) {

        log.info("[getMapping] inside the getMapping with branchCode {}, countryCode {}, pgpeCode {}, action {}, statusCst {}",
                branchCode, countryCode, pgpeCode, action, statusCst);

        Map<String, Object> queryParams = new HashMap<>();
        queryParams.put("branchCode", branchCode);
        queryParams.put("countryCode", countryCode);
        queryParams.put("pgpeCode", pgpeCode);
        queryParams.put("action", action);
        queryParams.put("statusCst", statusCst);

        if (statusCxt != null) queryParams.put("statusCxt", statusCxt);
        if (prodCode != null) queryParams.put("prodCode", prodCode);

        // Prepare wildcard filtering fields (optional ones)
        if (transactionTypeCode != null) queryParams.put("transactionTypeCode", transactionTypeCode);
        if (subTransactionTypeCode != null) queryParams.put("subTransactionTypeCode", subTransactionTypeCode);
        if (productStatusCode != null) queryParams.put("productStatusCode", productStatusCode);
        if (transactionStatusCode != null) queryParams.put("transactionStatusCode", transactionStatusCode);

        // Create Specification from ParseUtils (already available in project)
        Specification<ExtTrackAndTraceMappingEntity> spec =
                ParseUtils.parseQuery(queryParams, ExtTrackAndTraceMappingEntity.class);

        List<ExtTrackAndTraceMappingEntity> resultEntities =
                extTrackAndTraceMappingRepository.findAll(spec);

        if (resultEntities.isEmpty()) {
            log.info("No result found for the given criteria.");
            return null;
        }

        List<ExternalTrackAndTraceMapping> models =
                commonMapper.getExtTrackAndTraceMappingModel(resultEntities);

        List<Object> priorityValues = Arrays.asList(
                transactionTypeCode,
                subTransactionTypeCode,
                productStatusCode,
                transactionStatusCode
        );

        PriorityQueue<ExternalTrackAndTraceMapping> pq =
                new PriorityQueue<>(new CustomComparator<>(fields, priorityValues, genericScoreCalculator));

        pq.addAll(models);
        return pq.peek();
    }
}

-----------

package com.bnpparibas.dpw.referential.controller;

import com.bnpparibas.dpw.referential.api.StaticDataApi;
import com.bnpparibas.dpw.referential.model.ExternalTrackAndTraceMapping;
import com.bnpparibas.dpw.referential.service.ExtTrackAndTraceMappingService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;

import java.util.Collections;
import java.util.List;

@Slf4j
@RestController
@RequiredArgsConstructor
public class StaticDataController implements StaticDataApi {

    private final ExtTrackAndTraceMappingService extTrackAndTraceMappingService;

    @Override
    public ResponseEntity<List<ExternalTrackAndTraceMapping>> getExternalTraceAndTrackMapping(
            String bnppuid,
            String branchCode,
            String countryCode,
            String pgpeCode,
            String action,
            String statusCst,
            String statusCxt,
            String prodCode,
            String transactionTypeCode,
            String subTransactionTypeCode,
            String productStatusCode,
            String transactionStatusCode) {

        log.info("[getExternalTraceAndTrackMapping] Requested with branchCode={}, countryCode={}, pgpeCode={}, action={}, statusCst={}",
                branchCode, countryCode, pgpeCode, action, statusCst);

        ExternalTrackAndTraceMapping mapping = extTrackAndTraceMappingService.getMapping(
                branchCode, countryCode, pgpeCode, action, statusCst, statusCxt,
                prodCode, transactionTypeCode, subTransactionTypeCode, productStatusCode, transactionStatusCode
        );

        return mapping == null
                ? ResponseEntity.ok(Collections.emptyList())
                : ResponseEntity.ok(List.of(mapping));
    }
}

--------------------------------------
// Test for ServiceImpl package com.bnpparibas.dpw.service;

import com.bmpparibas.dpw.entity.ExtTrackAndTraceMappingEntity; import com.bmpparibas.dpw.mapper.CommonMapper; import com.bmpparibas.dpw.referential.model.ExtTrackAndTraceMapping; import com.bmpparibas.dpw.repository.ExtTrackAndTraceMappingRepository; import com.bmpparibas.dpw.util.ScoreCalculator; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.MockitoAnnotations;

import java.util.Collections; import java.util.List;

import static org.junit.jupiter.api.Assertions.; import static org.mockito.Mockito.;

public class ExtTrackAndTraceMappingServiceImplTest {

@Mock
private ExtTrackAndTraceMappingRepository repository;

@Mock
private CommonMapper commonMapper;

@Mock
private ScoreCalculator scoreCalculator;

@InjectMocks
private ExtTrackAndTraceMappingServiceImpl service;

@BeforeEach
public void setup() {
    MockitoAnnotations.openMocks(this);
}

@Test
void testGetMapping_ReturnsBestMatch() {
    ExtTrackAndTraceMappingEntity entity = new ExtTrackAndTraceMappingEntity();
    ExtTrackAndTraceMapping model = new ExtTrackAndTraceMapping();

    when(repository.getextMapping(any(), any(), any(), any(), any(), any(), any()))
            .thenReturn(List.of(entity));
    when(commonMapper.getExtTrackAndTraceMappingModel(any()))
            .thenReturn(List.of(model));

    ExtTrackAndTraceMapping result = service.getMapping("30004", "FR", "ILCI", "Validated", "Active", null, null, null, null);
    assertNotNull(result);
}

@Test
void testGetMapping_ReturnsNullIfEmpty() {
    when(repository.getextMapping(any(), any(), any(), any(), any(), any(), any()))
            .thenReturn(Collections.emptyList());

    ExtTrackAndTraceMapping result = service.getMapping("30004", "FR", "ILCI", "Validated", "Active", null, null, null, null);
    assertNull(result);
}

}

// Test for Controller package com.bnpparibas.dpw.controller;

import com.bmpparibas.dpw.referential.model.ExtTrackAndTraceMapping; import com.bnpparibas.dpw.service.ExtTrackAndTraceMappingService; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import org.springframework.http.ResponseEntity;

import java.util.List;

import static org.junit.jupiter.api.Assertions.; import static org.mockito.Mockito.;

public class StaticDataControllerTest {

@Mock
private ExtTrackAndTraceMappingService service;

@InjectMocks
private StaticDataController controller;

@BeforeEach
public void setup() {
    MockitoAnnotations.openMocks(this);
}

@Test
void testGetExtTraceAndTrackMapping_Found() {
    ExtTrackAndTraceMapping mapping = new ExtTrackAndTraceMapping();
    when(service.getMapping(any(), any(), any(), any(), any(), any(), any(), any(), any()))
            .thenReturn(mapping);

    ResponseEntity<List<ExtTrackAndTraceMapping>> response =
            controller.getExtTraceAndTrackMapping("uid", "30004", "FR", "ILCI", "Validated", "Active", null, null, null);

    assertEquals(200, response.getStatusCodeValue());
    assertEquals(1, response.getBody().size());
}

@Test
void testGetExtTraceAndTrackMapping_NotFound() {
    when(service.getMapping(any(), any(), any(), any(), any(), any(), any(), any(), any()))
            .thenReturn(null);

    ResponseEntity<List<ExtTrackAndTraceMapping>> response =
            controller.getExtTraceAndTrackMapping("uid", "30004", "FR", "ILCI", "Validated", "Active", null, null, null);

    assertEquals(200, response.getStatusCodeValue());
    assertTrue(response.getBody().isEmpty());
}

}

// Repository Test (optional integration with H2, not covered here due to complexity) // Usually tested indirectly via Service integration tests









-----------------------------------------------

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface ExtTrackAndTraceMappingRepository extends DpwAppRepository<ExtTrackAndTraceMappingEntity, Long> {

    @Query("SELECT e FROM ExtTrackAndTraceMappingEntity e " +
           "WHERE e.branchCode = :branchCode " +
           "AND e.countryCode = :countryCode " +
           "AND e.pgpeCode = :pgpeCode " +
           "AND e.action = :action " +
           "AND UPPER(e.statusCst) = UPPER(:statusCst) " +
           "AND (:statusCxt IS NULL OR e.statusCxt = :statusCxt) " +
           "AND (:prodCode IS NULL OR e.productCode = :prodCode)")
    List<ExtTrackAndTraceMappingEntity> findMatchingMappings(
        @Param("branchCode") String branchCode,
        @Param("countryCode") String countryCode,
        @Param("pgpeCode") String pgpeCode,
        @Param("action") String action,
        @Param("statusCst") String statusCst,
        @Param("statusCxt") String statusCxt,
        @Param("prodCode") String prodCode
    );
}













@Query("SELECT e FROM ExtTrackAndTraceMappingEntity e " +
       "WHERE e.branchCode = :branchCode " +
       "AND e.countryCode = :countryCode " +
       "AND e.pgpeCode = :pgpeCode " +
       "AND e.action = :action " +
       "AND UPPER(e.statusCst) = UPPER(:statusCst) " +
       "AND (:statusCxt IS NULL OR e.statusCxt = :statusCxt) " +
       "AND (:prodCode IS NULL OR e.productCode = :prodCode)")
List<ExtTrackAndTraceMappingEntity> findMappings(
    @Param("branchCode") String branchCode,
    @Param("countryCode") String countryCode,
    @Param("pgpeCode") String pgpeCode,
    @Param("action") String action,
    @Param("statusCst") String statusCst,
    @Param("statusCxt") String statusCxt,
    @Param("prodCode") String prodCode
);




!!!!!!!!!!!!!!!!!!!// ExtTrackAndTraceMappingServiceImplTest.java

import static org.junit.jupiter.api.Assertions.; import static org.mockito.BDDMockito.;

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity; import com.bnpparibas.dpw.repository.ExtTrackAndTraceMappingRepository; import com.bnpparibas.dpw.service.impl.ExtTrackAndTraceMappingServiceImpl; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Optional;

@ExtendWith(MockitoExtension.class) public class ExtTrackAndTraceMappingServiceImplTest {

@Mock
private ExtTrackAndTraceMappingRepository repository;

@InjectMocks
private ExtTrackAndTraceMappingServiceImpl service;

private ExtTrackAndTraceMappingEntity entity;

@BeforeEach
public void setup() {
    entity = new ExtTrackAndTraceMappingEntity();
    entity.setId(3L);
    entity.setBranchCode("30004");
    entity.setCountryCode("FR");
    entity.setPgpeCode("ILCI");
    entity.setAction("Validated");
    entity.setStatusCst("Active");
    entity.setStatusCxt("AC");
    entity.setProductCode("IC");
    entity.setTransactionTypeCode("TTC");
}

@Test
public void testGetMapping_Found() {
    given(repository.findByBranchCodeAndCountryCodeAndPgpeCodeAndActionAndStatusCst(
            "30004", "FR", "ILCI", "Validated", "Active"))
            .willReturn(entity);

    Optional<ExtTrackAndTraceMappingEntity> result = service.getMapping("30004", "FR", "ILCI", "Validated", "Active");

    assertTrue(result.isPresent());
    ExtTrackAndTraceMappingEntity actual = result.get();

    // Mandatory fields not null
    assertNotNull(actual.getBranchCode());
    assertNotNull(actual.getCountryCode());
    assertNotNull(actual.getPgpeCode());
    assertNotNull(actual.getAction());
    assertNotNull(actual.getStatusCst());

    // All fields value check
    assertEquals("30004", actual.getBranchCode());
    assertEquals("FR", actual.getCountryCode());
    assertEquals("ILCI", actual.getPgpeCode());
    assertEquals("Validated", actual.getAction());
    assertEquals("Active", actual.getStatusCst());
    assertEquals("AC", actual.getStatusCxt());
    assertEquals("IC", actual.getProductCode());
    assertEquals("TTC", actual.getTransactionTypeCode());
}

@Test
public void testGetMapping_NotFound() {
    given(repository.findByBranchCodeAndCountryCodeAndPgpeCodeAndActionAndStatusCst(
            "30004", "FR", "ILCI", "Validated", "Active"))
            .willReturn(null);

    Optional<ExtTrackAndTraceMappingEntity> result = service.getMapping("30004", "FR", "ILCI", "Validated", "Active");

    assertTrue(result.isEmpty());
}

}



--------------

package com.bnpparibas.dpw.service;

import com.bnpparibas.dpw.entity.ExtTrackAndTraceMappingEntity;
import com.bnpparibas.dpw.service.impl.ExtTrackAndTraceMappingServiceImpl;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

public class ExtTrackAndTraceMappingServiceTest {

    @Mock
    private ExtTrackAndTraceMappingService service;

    @Test
    public void testGetMappingReturnsExpectedEntity() {
        ExtTrackAndTraceMappingEntity expectedEntity = new ExtTrackAndTraceMappingEntity();
        expectedEntity.setBranchCode("30004");
        expectedEntity.setCountryCode("FR");
        expectedEntity.setPgpeCode("ILCI");
        expectedEntity.setAction("Validated");
        expectedEntity.setStatusCst("Active");

        when(service.getMapping("30004", "FR", "ILCI", "Validated", "Active"))
            .thenReturn(Optional.of(expectedEntity));

        Optional<ExtTrackAndTraceMappingEntity> actual = service.getMapping("30004", "FR", "ILCI", "Validated", "Active");

        assertEquals(expectedEntity.getBranchCode(), actual.get().getBranchCode());
    }
}













--------------------------

INSERT INTO DPW_EXT_TRACK_TRACE_MAPPING (
    ID, BRANCH_CODE, COUNTRY_CODE, PGPE_CODE, ACTION, STATUS_CST, STATUS_CXT, PROD_CODE, TRANSACTION_TYPE_CODE
) VALUES (
    1, '3000', 'FR', 'ILCI', 'Validated', 'Active', 'AC', 'IC', 'T1'
);

INSERT INTO DPW_EXT_TRACK_TRACE_MAPPING (
    ID, BRANCH_CODE, COUNTRY_CODE, PGPE_CODE, ACTION, STATUS_CST, STATUS_CXT, PROD_CODE, TRANSACTION_TYPE_CODE
) VALUES (
    2, '3001', 'IN', 'ILCI', 'Rejected', 'Inactive', 'IN', 'IC', 'T2'
);

INSERT INTO DPW_EXT_TRACK_TRACE_MAPPING (
    ID, BRANCH_CODE, COUNTRY_CODE, PGPE_CODE, ACTION, STATUS_CST, STATUS_CXT, PROD_CODE, TRANSACTION_TYPE_CODE
) VALUES (
    3, '3002', 'US', 'ILC2', 'Pending', 'OnHold', 'OH', NULL, NULL
);





// models/claim.model.ts
import { Policy } from './policy.model';

export interface Claim {
  id: number;
  claimAmount: number;
  claimType: string;
  status: string;
  policy: Policy;
}

___________________________________________________________________________________________________

// models/policy.model.ts
export interface Policy {
  policyHolderName: string;
  planType: string;
  insuredAmount: number;
  tenure: number;
  premiumFrequency: string;
  policyStatus: string;
}

__________________________________________________________________________________________________________
// approve-claim.component.ts
import { Component, OnInit } from '@angular/core';
import { ClaimService } from '../authservice/claim.service';
import { Router } from '@angular/router';
import { Claim } from '../models/claim.model';

@Component({
  selector: 'app-approve-claim',
  templateUrl: './claim-approval.component.html',
  styleUrls: ['./claim-approval.component.css']
})
export class ApproveClaimComponent implements OnInit {
  pendingClaims: Claim[] = [];
  errorMessage: string = "";

  constructor(private claimService: ClaimService, private router: Router) {}

  ngOnInit(): void {
    this.fetchPendingClaims();
  }

  fetchPendingClaims(): void {
    this.claimService.getClaimsForApproval().subscribe({
      next: claims => this.pendingClaims = claims,
      error: err => this.errorMessage = 'Error loading pending claims'
    });
  }

  approveClaim(claimId: number): void {
    this.claimService.approveClaim(claimId).subscribe({
      next: () => this.fetchPendingClaims(),
      error: err => console.error('Error approving claim', err)
    });
  }

  rejectClaim(claimId: number): void {
    this.claimService.rejectClaim(claimId).subscribe({
      next: () => this.fetchPendingClaims(),
      error: err => console.error('Error rejecting claim', err)
    });
  }
}
_____________________________________________________________________________________________________________________

<div class="approve-container">
  <h2>Pending Claims for Approval</h2>

  <div *ngIf="errorMessage" class="error">{{ errorMessage }}</div>

  <table *ngIf="pendingClaims.length > 0" class="claim-table">
    <thead>
      <tr>
        <th>Claim ID</th>
        <th>Claim Amount</th>
        <th>Type</th>
        <th>Status</th>
        <th>Policy Details</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
      <tr *ngFor="let claim of pendingClaims">
        <td>{{ claim.id }}</td>
        <td>{{ claim.claimAmount }}</td>
        <td>{{ claim.claimType }}</td>
        <td>{{ claim.status }}</td>
        <td>
          <div *ngIf="claim.policy">
            <p><strong>Holder Name:</strong> {{ claim.policy.policyHolderName }}</p>
            <p><strong>Plan Type:</strong> {{ claim.policy.planType }}</p>
            <p><strong>Insured Amount:</strong> â‚¹{{ claim.policy.insuredAmount }}</p>
            <p><strong>Tenure:</strong> {{ claim.policy.tenure }} years</p>
            <p><strong>Premium Frequency:</strong> {{ claim.policy.premiumFrequency }}</p>
            <p><strong>Status:</strong> {{ claim.policy.policyStatus }}</p>
          </div>
        </td>
        <td>
          <button (click)="approveClaim(claim.id)" class="btn-approve">Approve</button>
          <button (click)="rejectClaim(claim.id)" class="btn-reject">Reject</button>
        </td>
      </tr>
    </tbody>
  </table>

  <div *ngIf="pendingClaims.length === 0">No pending claims to display.</div>
</div>
_________________________________________________________________________________________________________

@Configuration
public class OrikaMapperConfig {

    @Bean
    public MapperFactory mapperFactory() {
        MapperFactory factory = new DefaultMapperFactory.Builder().build();
        factory.classMap(User.class, UserDTO.class)
                .byDefault()
                .register();
        return factory;
    }

    @Bean
    public MapperFacade mapperFacade(MapperFactory mapperFactory) {
        return mapperFactory.getMapperFacade();
    }
}
____________________________________________________________________________________________________________________

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final MapperFacade mapper;

    @Override
    public UserDTO createUser(UserDTO userDTO){
        User user = mapper.map(userDTO, User.class);
        return mapper.map(userRepository.save(user), UserDTO.class);
    }

    @Override
    public UserDTO getUserById(Long id) {
        User user = userRepository.findById(id).orElseThrow(() -> new RuntimeException("User not found"));
        return mapper.map(user, UserDTO.class);
    }

    @Override
    public UserDTO updateUser(Long id, UserDTO userDTO) {
        User existingUser = userRepository.findById(id).orElseThrow(() -> new RuntimeException("User not found"));

        existingUser.setUsername(userDTO.getUsername());
        existingUser.setPassword(userDTO.getPassword());
        existingUser.setRole(userDTO.getRole());

        return mapper.map(userRepository.save(existingUser), UserDTO.class);
    }

    @Override
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }

    @Override
    public List<UserDTO> getAllUsers() {
        return userRepository.findAll()
                .stream()
                .map(user -> mapper.map(user, UserDTO.class))
                .collect(Collectors.toList());
    }

    @Override
    public UserDTO validateUser(String username, String password) {
        Optional<User> userOpt = userRepository.findByUsernameAndPassword(username, password);
        return userOpt.map(user -> mapper.map(user, UserDTO.class)).orElse(null);
    }
}
__________________________________________________________________________________

public interface UserService {

    UserDTO createUser(UserDTO userDTO);

    UserDTO getUserById(Long id);

    UserDTO updateUser(Long id, UserDTO userDTO);

    void deleteUser(Long id);

    List<UserDTO> getAllUsers();

    UserDTO validateUser(String username, String password);
}


----------------------------------------------------------------------------------------------------------------------------------

@RestController
@CrossOrigin(origins = "http://localhost:4200")
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @PostMapping("/login")
    public ResponseEntity<?> loginUser(@RequestBody UserDTO userDTO) {
        UserDTO user = userService.validateUser(userDTO.getUsername(), userDTO.getPassword());
        if (user != null) {
            return ResponseEntity.ok(user);
        } else {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid credentials");
        }
    }

    @PostMapping("/register")
    public ResponseEntity<UserDTO> createUser(@RequestBody UserDTO userDTO) {
        return ResponseEntity.ok(userService.createUser(userDTO));
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserDTO> getUserById(@PathVariable Long id) {
        return ResponseEntity.ok(userService.getUserById(id));
    }

    @GetMapping("/")
    public ResponseEntity<List<UserDTO>> getAllUsers() {
        return ResponseEntity.ok(userService.getAllUsers());
    }

    @PutMapping("/{id}")
    public ResponseEntity<UserDTO> updateUser(@PathVariable long id, @RequestBody UserDTO userDTO) {
        return ResponseEntity.ok(userService.updateUser(id, userDTO));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable long id) {
        userService.deleteUser(id);
        return ResponseEntity.ok().build();
    }
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++











